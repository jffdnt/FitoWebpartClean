"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    opacityEnterAtom: function() {
        return opacityEnterAtom;
    },
    opacityExitAtom: function() {
        return opacityExitAtom;
    },
    sizeEnterAtom: function() {
        return sizeEnterAtom;
    },
    sizeExitAtom: function() {
        return sizeExitAtom;
    },
    whitespaceEnterAtom: function() {
        return whitespaceEnterAtom;
    },
    whitespaceExitAtom: function() {
        return whitespaceExitAtom;
    }
});
// ----- SIZE -----
const sizeValuesForOrientation = (orientation, element)=>{
    const sizeName = orientation === 'horizontal' ? 'maxWidth' : 'maxHeight';
    const overflowName = orientation === 'horizontal' ? 'overflowX' : 'overflowY';
    const measuredSize = orientation === 'horizontal' ? element.scrollWidth : element.scrollHeight;
    const toSize = `${measuredSize}px`;
    return {
        sizeName,
        overflowName,
        toSize
    };
};
const sizeEnterAtom = ({ orientation, duration, easing, element, fromSize = '0' })=>{
    const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
    return {
        keyframes: [
            {
                [sizeName]: fromSize,
                [overflowName]: 'hidden'
            },
            {
                [sizeName]: toSize,
                offset: 0.9999,
                [overflowName]: 'hidden'
            },
            {
                [sizeName]: 'unset',
                [overflowName]: 'unset'
            }
        ],
        duration,
        easing
    };
};
const sizeExitAtom = ({ orientation, duration, easing, element, delay = 0, fromSize = '0' })=>{
    const { sizeName, overflowName, toSize } = sizeValuesForOrientation(orientation, element);
    return {
        keyframes: [
            {
                [sizeName]: toSize,
                [overflowName]: 'hidden'
            },
            {
                [sizeName]: fromSize,
                [overflowName]: 'hidden'
            }
        ],
        duration,
        easing,
        fill: 'both',
        delay
    };
};
// ----- WHITESPACE -----
// Whitespace animation includes padding and margin.
const whitespaceValuesForOrientation = (orientation)=>{
    // horizontal whitespace collapse
    if (orientation === 'horizontal') {
        return {
            paddingStart: 'paddingInlineStart',
            paddingEnd: 'paddingInlineEnd',
            marginStart: 'marginInlineStart',
            marginEnd: 'marginInlineEnd'
        };
    }
    // vertical whitespace collapse
    return {
        paddingStart: 'paddingBlockStart',
        paddingEnd: 'paddingBlockEnd',
        marginStart: 'marginBlockStart',
        marginEnd: 'marginBlockEnd'
    };
};
const whitespaceEnterAtom = ({ orientation, duration, easing })=>{
    const { paddingStart, paddingEnd, marginStart, marginEnd } = whitespaceValuesForOrientation(orientation);
    return {
        // Animate from whitespace of zero to the current whitespace, by omitting the ending keyframe.
        keyframes: [
            {
                [paddingStart]: '0',
                [paddingEnd]: '0',
                [marginStart]: '0',
                [marginEnd]: '0',
                offset: 0
            }
        ],
        duration,
        easing
    };
};
const whitespaceExitAtom = ({ orientation, duration, easing, delay = 0 })=>{
    const { paddingStart, paddingEnd, marginStart, marginEnd } = whitespaceValuesForOrientation(orientation);
    return {
        // Animate from the current whitespace to whitespace of zero, by using offset 1 and omitting the starting keyframe.
        keyframes: [
            {
                [paddingStart]: '0',
                [paddingEnd]: '0',
                [marginStart]: '0',
                [marginEnd]: '0',
                offset: 1
            }
        ],
        duration,
        easing,
        fill: 'forwards',
        delay
    };
};
const opacityEnterAtom = ({ duration, easing, delay = 0, fromOpacity = 0, toOpacity = 1 })=>({
        keyframes: [
            {
                opacity: fromOpacity
            },
            {
                opacity: toOpacity
            }
        ],
        duration,
        easing,
        delay,
        fill: 'both'
    });
const opacityExitAtom = ({ duration, easing, fromOpacity = 0, toOpacity = 1 })=>({
        keyframes: [
            {
                opacity: toOpacity
            },
            {
                opacity: fromOpacity
            }
        ],
        duration,
        easing
    });
