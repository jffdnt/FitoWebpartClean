"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processNonLocalizedAsset = exports.processLocalizedAsset = exports.PLACEHOLDER_REGEX = void 0;
const Constants = __importStar(require("./utilities/Constants"));
exports.PLACEHOLDER_REGEX = new RegExp(`${Constants.STRING_PLACEHOLDER_PREFIX}_(\\\\*)_([A-C])_([0-9a-f]+)`, 'g');
function processLocalizedAsset(options) {
    const { compilation, asset, chunk, filenameTemplate, locales, formatLocaleForFilenameFn } = options;
    const { sources, WebpackError } = compilation.compiler.webpack;
    const rawSource = new sources.CachedSource(asset.source);
    const assetSource = rawSource.source().toString();
    const parsedAsset = _parseStringToReconstructionSequence(options.plugin, assetSource, formatLocaleForFilenameFn);
    const { issues } = parsedAsset;
    const localizedFiles = {};
    chunk.localizedFiles = localizedFiles;
    const { info: originInfo, name: originName } = asset;
    if (!originInfo.related) {
        originInfo.related = {};
    }
    for (const locale of locales) {
        const { issues: localeIssues, result: localeResult } = _reconstructLocalized(new sources.ReplaceSource(rawSource, locale), parsedAsset.reconstructionSeries, locale, options.fillMissingTranslationStrings ? options.defaultLocale : undefined);
        for (const issue of localeIssues) {
            issues.push(issue);
        }
        const data = {
            chunk,
            contentHashType: 'javascript',
            // The locale property will get processed by the extension to the getAssetPath hook
            locale
        };
        const fileName = compilation.getAssetPath(filenameTemplate, data);
        originInfo.related[locale] = fileName;
        const info = {
            ...originInfo,
            locale
        };
        const wrapped = new sources.CachedSource(localeResult);
        localizedFiles[locale] = fileName;
        // If file already exists
        if (originName === fileName) {
            // This helper throws if the asset doesn't already exist
            compilation.updateAsset(fileName, wrapped, info);
        }
        else {
            // This helper throws if the asset already exists
            compilation.emitAsset(fileName, wrapped, info);
        }
    }
    if (issues.length > 0) {
        compilation.errors.push(new WebpackError(`localization:\n${issues.map((issue) => `  ${issue}`).join('\n')}`));
    }
    return localizedFiles;
}
exports.processLocalizedAsset = processLocalizedAsset;
function processNonLocalizedAsset(options) {
    const { asset, fileName, compilation, formatLocaleForFilenameFn } = options;
    const { sources, WebpackError } = compilation.compiler.webpack;
    const rawSource = new sources.CachedSource(asset.source);
    const assetSource = rawSource.source().toString();
    const parsedAsset = _parseStringToReconstructionSequence(options.plugin, assetSource, formatLocaleForFilenameFn);
    const { info: originInfo } = asset;
    const { issues } = parsedAsset;
    const locale = options.noStringsLocaleName;
    const { issues: localeIssues, result } = _reconstructNonLocalized(new sources.ReplaceSource(rawSource, locale), parsedAsset.reconstructionSeries, locale);
    for (const issue of localeIssues) {
        issues.push(issue);
    }
    const info = {
        ...originInfo,
        locale
    };
    const wrapped = new sources.CachedSource(result);
    compilation.updateAsset(fileName, wrapped, info);
    if (issues.length > 0) {
        options.compilation.errors.push(new WebpackError(`localization:\n${issues.map((issue) => `  ${issue}`).join('\n')}`));
    }
}
exports.processNonLocalizedAsset = processNonLocalizedAsset;
const ESCAPE_MAP = new Map([
    ['\r', 'r'],
    ['\n', 'n'],
    ['\t', 't'],
    ['"', 'u0022'],
    ["'", 'u0027']
]);
const BACKSLASH_REGEX = /\\/g;
const ESCAPE_REGEX = /[\r\n\t"']/g;
function _reconstructLocalized(result, reconstructionSeries, locale, fallbackLocale) {
    const issues = [];
    for (const element of reconstructionSeries) {
        switch (element.kind) {
            case 'localized': {
                const { data } = element;
                let newValue = data.valuesByLocale.get(locale);
                if (newValue === undefined) {
                    if (fallbackLocale) {
                        newValue = data.valuesByLocale.get(fallbackLocale);
                    }
                    else {
                        issues.push(`The string "${data.stringName}" in "${data.locFilePath}" is missing in ` +
                            `the locale ${locale}`);
                        newValue = '-- MISSING STRING --';
                    }
                }
                const escapedBackslash = element.escapedBackslash || '\\';
                if (newValue.includes('\\')) {
                    // The vast majority of localized strings do not contain `\\`, so this check avoids an allocation.
                    // Replace backslashes with the properly escaped backslash
                    BACKSLASH_REGEX.lastIndex = -1;
                    newValue = newValue.replace(BACKSLASH_REGEX, escapedBackslash);
                }
                // Ensure the the quotemark, apostrophe, tab, and newline characters are properly escaped
                ESCAPE_REGEX.lastIndex = -1;
                if (ESCAPE_REGEX.test(newValue)) {
                    // The majority of localized strings do not contain the characters that need to be escaped,
                    // so this check avoids an allocation.
                    // @todo: look into using JSON.parse(...) to get the escaping characters
                    const escapingCharacterSequence = escapedBackslash.slice(escapedBackslash.length / 2);
                    newValue = newValue.replace(ESCAPE_REGEX, (match) => `${escapingCharacterSequence}${ESCAPE_MAP.get(match)}`);
                }
                result.replace(element.start, element.end - 1, newValue);
                break;
            }
            case 'dynamic': {
                const newValue = element.valueFn(locale);
                result.replace(element.start, element.end - 1, newValue);
                break;
            }
        }
    }
    return {
        issues,
        result
    };
}
function _reconstructNonLocalized(result, reconstructionSeries, noStringsLocaleName) {
    const issues = [];
    for (const element of reconstructionSeries) {
        switch (element.kind) {
            case 'localized': {
                issues.push(`The string "${element.data.stringName}" in "${element.data.locFilePath}" appeared in an asset ` +
                    'that is not expected to contain localized resources.');
                const newValue = '-- NOT EXPECTED TO BE LOCALIZED --';
                result.replace(element.start, element.end - 1, newValue);
                break;
            }
            case 'dynamic': {
                const newValue = element.valueFn(noStringsLocaleName);
                result.replace(element.start, element.end - 1, newValue);
                break;
            }
        }
    }
    return {
        issues,
        result
    };
}
function _parseStringToReconstructionSequence(plugin, source, formatLocaleForFilenameFn) {
    const issues = [];
    const reconstructionSeries = [];
    const jsonStringifyFormatLocaleForFilenameFn = (locale) => JSON.stringify(formatLocaleForFilenameFn(locale));
    for (const regexResult of source.matchAll(exports.PLACEHOLDER_REGEX)) {
        const [placeholder, escapedBackslash, elementLabel, placeholderSerialNumber] = regexResult;
        const start = regexResult.index;
        const end = start + placeholder.length;
        let localizedReconstructionElement;
        switch (elementLabel) {
            case Constants.STRING_PLACEHOLDER_LABEL: {
                const stringData = plugin.getDataForSerialNumber(placeholderSerialNumber);
                if (!stringData) {
                    issues.push(`Missing placeholder ${placeholder}`);
                    continue;
                }
                else {
                    const localizedElement = {
                        kind: 'localized',
                        start,
                        end,
                        escapedBackslash,
                        data: stringData
                    };
                    localizedReconstructionElement = localizedElement;
                }
                break;
            }
            case Constants.LOCALE_NAME_PLACEHOLDER_LABEL: {
                const dynamicElement = {
                    kind: 'dynamic',
                    start,
                    end,
                    escapedBackslash,
                    valueFn: formatLocaleForFilenameFn
                };
                localizedReconstructionElement = dynamicElement;
                break;
            }
            case Constants.JSONP_PLACEHOLDER_LABEL: {
                const dynamicElement = {
                    kind: 'dynamic',
                    start,
                    end,
                    escapedBackslash,
                    valueFn: jsonStringifyFormatLocaleForFilenameFn
                };
                localizedReconstructionElement = dynamicElement;
                break;
            }
            default: {
                throw new Error(`Unexpected label ${elementLabel}`);
            }
        }
        reconstructionSeries.push(localizedReconstructionElement);
    }
    return {
        issues,
        reconstructionSeries
    };
}
//# sourceMappingURL=AssetProcessor.js.map