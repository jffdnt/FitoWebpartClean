"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.LookupByPath = void 0;
/**
 * This class is used to associate path-like-strings, such as those returned by `git` commands,
 * with entities that correspond with ancestor folders, such as Rush Projects or npm packages.
 *
 * It is optimized for efficiently locating the nearest ancestor path with an associated value.
 *
 * It is implemented as a Trie (https://en.wikipedia.org/wiki/Trie) data structure, with each edge
 * being a path segment.
 *
 * @example
 * ```ts
 * const trie = new LookupByPath([['foo', 1], ['bar', 2], ['foo/bar', 3]]);
 * trie.findChildPath('foo'); // returns 1
 * trie.findChildPath('foo/baz'); // returns 1
 * trie.findChildPath('baz'); // returns undefined
 * trie.findChildPath('foo/bar/baz'); returns 3
 * trie.findChildPath('bar/foo/bar'); returns 2
 * ```
 * @beta
 */
class LookupByPath {
    /**
     * Constructs a new `LookupByPath`
     *
     * @param entries - Initial path-value pairs to populate the trie.
     */
    constructor(entries, delimiter) {
        this._root = {
            value: undefined,
            children: undefined
        };
        this.delimiter = delimiter !== null && delimiter !== void 0 ? delimiter : '/';
        if (entries) {
            for (const [path, item] of entries) {
                this.setItem(path, item);
            }
        }
    }
    /**
     * Iterates over the segments of a serialized path.
     *
     * @example
     *
     * `LookupByPath.iteratePathSegments('foo/bar/baz')` yields 'foo', 'bar', 'baz'
     *
     * `LookupByPath.iteratePathSegments('foo\\bar\\baz', '\\')` yields 'foo', 'bar', 'baz'
     */
    static *iteratePathSegments(serializedPath, delimiter = '/') {
        for (const prefixMatch of this._iteratePrefixes(serializedPath, delimiter)) {
            yield prefixMatch.prefix;
        }
    }
    static *_iteratePrefixes(input, delimiter = '/') {
        if (!input) {
            return;
        }
        let previousIndex = 0;
        let nextIndex = input.indexOf(delimiter);
        // Leading segments
        while (nextIndex >= 0) {
            yield {
                prefix: input.slice(previousIndex, nextIndex),
                index: nextIndex
            };
            previousIndex = nextIndex + 1;
            nextIndex = input.indexOf(delimiter, previousIndex);
        }
        // Last segment
        if (previousIndex < input.length) {
            yield {
                prefix: input.slice(previousIndex, input.length),
                index: input.length
            };
        }
    }
    /**
     * Associates the value with the specified serialized path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItem(serializedPath, value) {
        return this.setItemFromSegments(LookupByPath.iteratePathSegments(serializedPath, this.delimiter), value);
    }
    /**
     * Associates the value with the specified path.
     * If a value is already associated, will overwrite.
     *
     * @returns this, for chained calls
     */
    setItemFromSegments(pathSegments, value) {
        let node = this._root;
        for (const segment of pathSegments) {
            if (!node.children) {
                node.children = new Map();
            }
            let child = node.children.get(segment);
            if (!child) {
                node.children.set(segment, (child = {
                    value: undefined,
                    children: undefined
                }));
            }
            node = child;
        }
        node.value = value;
        return this;
    }
    /**
     * Searches for the item associated with `childPath`, or the nearest ancestor of that path that
     * has an associated item.
     *
     * @returns the found item, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * trie.findChildPath('foo/baz'); // returns 1
     * trie.findChildPath('foo/bar/baz'); // returns 2
     * ```
     */
    findChildPath(childPath) {
        return this.findChildPathFromSegments(LookupByPath.iteratePathSegments(childPath, this.delimiter));
    }
    /**
     * Searches for the item for which the recorded prefix is the longest matching prefix of `query`.
     * Obtains both the item and the length of the matched prefix, so that the remainder of the path can be
     * extracted.
     *
     * @returns the found item and the length of the matched prefix, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * trie.findLongestPrefixMatch('foo/baz'); // returns { item: 1, index: 3 }
     * trie.findLongestPrefixMatch('foo/bar/baz'); // returns { item: 2, index: 7 }
     * ```
     */
    findLongestPrefixMatch(query) {
        return this._findLongestPrefixMatch(LookupByPath._iteratePrefixes(query, this.delimiter));
    }
    /**
     * Searches for the item associated with `childPathSegments`, or the nearest ancestor of that path that
     * has an associated item.
     *
     * @returns the found item, or `undefined` if no item was found
     *
     * @example
     * ```ts
     * const trie = new LookupByPath([['foo', 1], ['foo/bar', 2]]);
     * trie.findChildPathFromSegments(['foo', 'baz']); // returns 1
     * trie.findChildPathFromSegments(['foo','bar', 'baz']); // returns 2
     * ```
     */
    findChildPathFromSegments(childPathSegments) {
        var _a;
        let node = this._root;
        let best = node.value;
        // Trivial cases
        if (node.children) {
            for (const segment of childPathSegments) {
                const child = node.children.get(segment);
                if (!child) {
                    break;
                }
                node = child;
                best = (_a = node.value) !== null && _a !== void 0 ? _a : best;
                if (!node.children) {
                    break;
                }
            }
        }
        return best;
    }
    /**
     * Iterates through progressively longer prefixes of a given string and returns as soon
     * as the number of candidate items that match the prefix are 1 or 0.
     *
     * If a match is present, returns the matched itme and the length of the matched prefix.
     *
     * @returns the found item, or `undefined` if no item was found
     */
    _findLongestPrefixMatch(prefixes) {
        let node = this._root;
        let best = node.value
            ? {
                value: node.value,
                index: 0,
                lastMatch: undefined
            }
            : undefined;
        // Trivial cases
        if (node.children) {
            for (const { prefix: hash, index } of prefixes) {
                const child = node.children.get(hash);
                if (!child) {
                    break;
                }
                node = child;
                if (node.value !== undefined) {
                    best = {
                        value: node.value,
                        index,
                        lastMatch: best
                    };
                }
                if (!node.children) {
                    break;
                }
            }
        }
        return best;
    }
}
exports.LookupByPath = LookupByPath;
//# sourceMappingURL=LookupByPath.js.map