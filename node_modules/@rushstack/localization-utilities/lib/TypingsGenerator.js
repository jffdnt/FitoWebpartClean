"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypingsGenerator = void 0;
const typings_generator_1 = require("@rushstack/typings-generator");
const LocFileParser_1 = require("./LocFileParser");
/**
 * This is a simple tool that generates .d.ts files for .loc.json, .resx.json, .resjson, and .resx files.
 *
 * @public
 */
class TypingsGenerator extends typings_generator_1.StringValuesTypingsGenerator {
    constructor(options) {
        const { ignoreString, processComment, resxNewlineNormalization, ignoreMissingResxComments, exportAsDefault } = options;
        const inferDefaultExportInterfaceNameFromFilename = typeof exportAsDefault === 'object'
            ? exportAsDefault.inferInterfaceNameFromFilename
            : undefined;
        super({
            ...options,
            fileExtensions: ['.resx', '.resx.json', '.loc.json', '.resjson'],
            parseAndGenerateTypings: (content, filePath, relativeFilePath) => {
                const locFileData = (0, LocFileParser_1.parseLocFile)({
                    filePath,
                    content,
                    terminal: this.terminal,
                    resxNewlineNormalization,
                    ignoreMissingResxComments,
                    ignoreString
                });
                const typings = [];
                // eslint-disable-next-line guard-for-in
                for (const [stringName, value] of Object.entries(locFileData)) {
                    let comment = value.comment;
                    if (processComment) {
                        comment = processComment(comment, relativeFilePath, stringName);
                    }
                    typings.push({
                        exportName: stringName,
                        comment
                    });
                }
                if (inferDefaultExportInterfaceNameFromFilename) {
                    const lastSlashIndex = Math.max(filePath.lastIndexOf('/'), filePath.lastIndexOf('\\'));
                    let extensionIndex = filePath.lastIndexOf('.');
                    if (filePath.slice(extensionIndex).toLowerCase() === '.json') {
                        extensionIndex = filePath.lastIndexOf('.', extensionIndex - 1);
                    }
                    const fileNameWithoutExtension = filePath.substring(lastSlashIndex + 1, extensionIndex);
                    const normalizedFileName = fileNameWithoutExtension.replace(/[^a-zA-Z0-9$_]/g, '');
                    const firstCharUpperCased = normalizedFileName.charAt(0).toUpperCase();
                    let interfaceName = `I${firstCharUpperCased}${normalizedFileName.slice(1)}`;
                    if (!interfaceName.endsWith('strings') && !interfaceName.endsWith('Strings')) {
                        interfaceName += 'Strings';
                    }
                    return {
                        typings,
                        exportAsDefault: {
                            interfaceName
                        }
                    };
                }
                else {
                    return {
                        typings
                    };
                }
            }
        });
    }
}
exports.TypingsGenerator = TypingsGenerator;
//# sourceMappingURL=TypingsGenerator.js.map