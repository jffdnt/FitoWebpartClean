"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManifestPlugin = exports.computeIntegrity = void 0;
const path = __importStar(require("node:path"));
const node_crypto_1 = __importDefault(require("node:crypto"));
const lodash = __importStar(require("lodash"));
const node_core_library_1 = require("@rushstack/node-core-library");
const localization_utilities_1 = require("@rushstack/localization-utilities");
const CumulativeManifestProcessor_1 = require("../cumulativeManifestProcessor/CumulativeManifestProcessor");
const LocalizedManifestModuleProcessor_1 = require("./LocalizedManifestModuleProcessor");
const IconHandler_1 = require("../utilities/IconHandler");
const TerminalHelper_1 = require("../utilities/TerminalHelper");
const normalizeLocaleName_1 = require("../../utilities/normalizeLocaleName");
const AsyncComponentPlugin_1 = require("../../plugins/webpackConfigurationPlugin/webpackPlugins/AsyncComponentPlugin");
const PLUGIN_NAME = 'manifest';
const HOT_UPDATE_FILENAME_REGEXP = /\.hot-update\.js$/;
const INTEGRITY_ALGORITHM_NAME = 'sha256';
/**
 * @internal
 */
function computeIntegrity(source) {
    const hash = node_crypto_1.default.createHash(INTEGRITY_ALGORITHM_NAME);
    if (typeof source === 'string') {
        hash.update(source);
    }
    else {
        if (!Array.isArray(source)) {
            source = [source];
        }
        for (const buffer of source) {
            hash.update(buffer);
        }
    }
    const hashDigest = hash.digest('base64');
    return `${INTEGRITY_ALGORITHM_NAME}-${hashDigest}`;
}
exports.computeIntegrity = computeIntegrity;
function _getChunkName(chunk) {
    return chunk.name || `Unnamed Chunk (#${chunk.id})`;
}
/**
 * @internal
 */
class ManifestPlugin {
    constructor(options) {
        this._parsedLocFileCache = new Map();
        this._options = options;
    }
    apply(compiler) {
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {
            const thisWebpack = compiler.webpack;
            class DevReleaseManifestSource extends thisWebpack.sources.RawSource {
                constructor({ serializedDebugManifest, serializedReleaseManifest }) {
                    super(serializedDebugManifest);
                    this.releaseManifest = serializedReleaseManifest;
                }
            }
            const { WebpackError } = thisWebpack;
            compilation.hooks.processAssets.tapPromise({
                name: PLUGIN_NAME,
                stage: thisWebpack.Compilation.PROCESS_ASSETS_STAGE_REPORT
            }, async () => {
                var _a, _b;
                const producedManifests = [];
                const asyncOnlyDependencies = new Set(((_a = this._options.asyncOnlyDependencies) === null || _a === void 0 ? void 0 : _a.asyncOnlyDependencyNames) || []);
                const asyncOnlyDependenciesViolationsAsErrors = !!((_b = this._options.asyncOnlyDependencies) === null || _b === void 0 ? void 0 : _b.violationsAsErrors);
                const terminal = TerminalHelper_1.TerminalHelper.getTerminalForWebpackPlugin(compilation);
                const componentDependenciesAuditFile = {
                    bundles: {}
                };
                for (const bundleEntry of this._options.bundleEntries) {
                    try {
                        const dependenciesForAudit = new Map();
                        const baseLoaderConfiguration = await this._generateLoaderConfigurationAsync(terminal, thisWebpack, bundleEntry.bundleName, compilation, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit);
                        for (const [componentId, bundleComponent] of Object.entries(bundleEntry.components)) {
                            const manifest = this._generateComponentManifest(terminal, thisWebpack, compilation, bundleComponent, baseLoaderConfiguration);
                            // Generate debug component manifest
                            manifest.loaderConfig.internalModuleBaseUrls = this._options.debugInternalModuleBaseUrls;
                            const serializedDebugManifest = JSON.stringify(manifest, undefined, 2);
                            producedManifests.push(manifest);
                            // Generate release component manifest
                            const releaseManifest = JSON.parse(JSON.stringify(manifest));
                            releaseManifest.loaderConfig.internalModuleBaseUrls = this._options.internalModuleBaseUrls;
                            const serializedReleaseManifest = JSON.stringify(releaseManifest, undefined, 2);
                            const manifestFilename = `${componentId}.manifest.json`;
                            compilation.emitAsset(manifestFilename, new DevReleaseManifestSource({ serializedDebugManifest, serializedReleaseManifest }));
                        }
                        const componentDependenciesAuditFileBundle = {
                            dependencies: Array.from(dependenciesForAudit.values())
                        };
                        componentDependenciesAuditFile.bundles[bundleEntry.bundleName] =
                            componentDependenciesAuditFileBundle;
                    }
                    catch (error) {
                        compilation.errors.push(error);
                        // Unable to generate manifest entrypoint - continue to the next bundle entry
                    }
                }
                if (this._options.componentDependenciesAuditDropPath) {
                    for (const untypedChunk of compilation.chunks) {
                        const chunk = untypedChunk;
                        if (chunk.hasRuntime()) {
                            const asyncChunks = {};
                            if (chunk[AsyncComponentPlugin_1.CHUNK_COMPONENT_MAP]) {
                                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                for (const [asyncChunk, externalComponents] of chunk[AsyncComponentPlugin_1.CHUNK_COMPONENT_MAP].entries()) {
                                    const dependenciesForAudit = new Map();
                                    for (const externalComponent of externalComponents) {
                                        this._populateLinkedExternalComponentInDependencyMap(externalComponent.componentName, externalComponent.componentId, externalComponent.componentVersion, true, dependenciesForAudit);
                                    }
                                    asyncChunks[_getChunkName(asyncChunk)] = {
                                        asyncComponentDependencies: Array.from(dependenciesForAudit.values())
                                    };
                                }
                            }
                            const chunkName = _getChunkName(chunk);
                            const entry = componentDependenciesAuditFile.bundles[chunkName];
                            if (entry) {
                                entry.asyncChunks = asyncChunks;
                            }
                            else {
                                // Allow the process to continue so that webpack can report the upstream error.
                                compilation.errors.push(new WebpackError(`ManifestPlugin: Unable to find entry point for async bundle "${chunkName}" in the manifest.`));
                            }
                        }
                    }
                    await node_core_library_1.JsonFile.saveAsync(componentDependenciesAuditFile, this._options.componentDependenciesAuditDropPath, {
                        ensureFolderExists: true,
                        ignoreUndefinedValues: true
                    });
                }
                await this._options.cumulativeManifestProcessor.generateCumulativeManifestAsync(producedManifests, this._options.manifestsJsFileMetadata, this._options.useManifestsJsonForComponentDependencies
                    ? CumulativeManifestProcessor_1.DependencyDiscoveryMode.shallow
                    : CumulativeManifestProcessor_1.DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
            });
        });
    }
    /**
     * @virtual
     */
    async _generateLoaderConfigurationAsync(terminal, thisWebpack, bundleName, compilation, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit) {
        const entrypoint = compilation.entrypoints.get(bundleName);
        if (!entrypoint) {
            throw new Error(`Expected to find an entrypoint with name "${bundleName}".`);
        }
        const runtimeChunk = this._getRuntimeChunk(bundleName, entrypoint);
        const scriptResources = await this._getExternalsScriptResourcesAsync(terminal, thisWebpack, bundleName, compilation, runtimeChunk, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit);
        const entrypointManifestModule = this._getEntryManifestModule(bundleName, runtimeChunk, compilation.assets);
        const loaderConfiguration = {
            internalModuleBaseUrls: this._options.internalModuleBaseUrls,
            entryModuleId: bundleName,
            scriptResources: {
                [bundleName]: entrypointManifestModule,
                ...scriptResources
            }
        };
        return loaderConfiguration;
    }
    _getRuntimeChunk(bundleName, entrypoint) {
        const runtimeChunk = entrypoint.getRuntimeChunk();
        if (!runtimeChunk) {
            throw new Error(`Expected to find an runtime chunk with name "${bundleName}".`);
        }
        else {
            return runtimeChunk;
        }
    }
    async _getExternalsScriptResourcesAsync(terminal, thisWebpack, bundleName, compilation, runtimeChunk, asyncOnlyDependencies, asyncOnlyDependenciesViolationsAsErrors, dependenciesForAudit) {
        const scriptResources = {};
        for (const module of compilation.chunkGraph.getChunkModules(runtimeChunk)) {
            if ((0, AsyncComponentPlugin_1.isExternalModule)(module)) {
                const externalName = module.userRequest;
                if (asyncOnlyDependencies.has(externalName)) {
                    const message = `Dependency "${externalName}" is marked as async-only, but is used ` +
                        `synchronously in bundle "${bundleName}"`;
                    if (asyncOnlyDependenciesViolationsAsErrors) {
                        terminal.writeError(message);
                    }
                    else {
                        terminal.writeWarning(message);
                    }
                }
                if (bundleName === externalName) {
                    throw new Error(`Bundle name "${bundleName}" collides with a dependent component name.`);
                }
                let externalManifestModules;
                const externalComponent = this._options.linkedExternals.get(externalName);
                if (externalComponent) {
                    if (!externalComponent.version) {
                        throw new Error(`External "${externalName}" has an unresolved version.`);
                    }
                    const externalComponentModule = {
                        type: 'component',
                        id: externalComponent.id,
                        version: externalComponent.version
                    };
                    this._populateLinkedExternalComponentInDependencyMap(externalComponent.name, externalComponent.id, externalComponent.version, true, dependenciesForAudit);
                    externalManifestModules = { [externalName]: externalComponentModule };
                }
                else {
                    const legacyExternal = this._options.tryGetLegacyExternalByNameAsync
                        ? await this._options.tryGetLegacyExternalByNameAsync(externalName)
                        : undefined;
                    if (legacyExternal) {
                        externalManifestModules = legacyExternal.moduleConfigurations;
                        for (const [assetName, assetContents] of Object.entries(legacyExternal.assets)) {
                            compilation.emitAsset(assetName, new thisWebpack.sources.RawSource(assetContents));
                        }
                    }
                    else {
                        throw new Error(`Did not find linked external "${externalName}" for bundle "${bundleName}".`);
                    }
                }
                for (const [name, external] of Object.entries(externalManifestModules)) {
                    scriptResources[name] = external;
                }
            }
        }
        return scriptResources;
    }
    _getRuntimeChunkInfo(bundleName, runtimeChunk, assets) {
        let filename;
        for (const file of runtimeChunk.files) {
            const isCandidate = path.extname(file) === '.js' &&
                // TODO - figure out if there is a way to determine this from module metadata
                !HOT_UPDATE_FILENAME_REGEXP.test(file);
            if (isCandidate) {
                if (filename) {
                    throw new Error(`Found more than one .js file in the runtime chunk for the "${bundleName}" bundle.`);
                }
                else {
                    filename = file;
                }
            }
        }
        if (!filename) {
            throw new Error(`Did not find a .js file in the runtime chunk for the "${bundleName}" bundle.`);
        }
        else {
            if (this._options.includeIntegrity) {
                const asset = assets[filename];
                if (!asset) {
                    throw new Error(`Did not find asset "${filename}" for the "${bundleName}" bundle.`);
                }
                else {
                    const integrity = computeIntegrity(asset.buffer());
                    return {
                        path: filename,
                        integrity
                    };
                }
            }
            else {
                return filename;
            }
        }
    }
    _generateComponentManifest(terminal, thisWebpack, compilation, bundleComponent, baseLoaderConfiguration) {
        const loaderConfig = { ...baseLoaderConfiguration };
        if (bundleComponent.exportName) {
            loaderConfig.exportName = bundleComponent.exportName;
        }
        const inputManifest = lodash.cloneDeep(bundleComponent.manifestData);
        delete inputManifest.$schema;
        switch (inputManifest.componentType) {
            case 'AdaptiveCardExtension':
            case 'WebPart': {
                this._processWebpartManifest(terminal, thisWebpack, compilation, bundleComponent.manifestPath, inputManifest);
                break;
            }
            case 'Application': {
                this._processApplicationManifest(terminal, thisWebpack, compilation, bundleComponent.manifestPath, inputManifest);
                break;
            }
            case 'Extension': {
                this._processExtensionsManifest(terminal, thisWebpack, compilation, bundleComponent.manifestPath, inputManifest);
                break;
            }
        }
        inputManifest.loaderConfig = loaderConfig;
        return inputManifest;
    }
    /**
     * Process and localize WebPart manifest.
     * @remarks Also used for AdaptiveCardExtension manifests
     */
    _processWebpartManifest(terminal, thisWebpack, compilation, manifestPath, manifest) {
        for (const entry of manifest.preconfiguredEntries) {
            entry.title = this._localizeString(terminal, thisWebpack, compilation, manifestPath, entry.title);
            entry.description = this._localizeString(terminal, thisWebpack, compilation, manifestPath, entry.description);
            if (entry.group) {
                entry.group = this._localizeString(terminal, thisWebpack, compilation, manifestPath, entry.group);
            }
            if (entry.tags) {
                // We don't allow more than 10 tags
                entry.tags = entry.tags
                    .slice(0, 10)
                    .map((tag) => this._localizeString(terminal, thisWebpack, compilation, manifestPath, tag));
            }
            entry.iconImageUrl = IconHandler_1.IconHandler.processIconPath(this._options.terminal, compilation, manifestPath, entry.iconImageUrl);
        }
    }
    _processApplicationManifest(terminal, thisWebpack, compilation, manifestPath, manifest) {
        manifest.title = this._localizeString(terminal, thisWebpack, compilation, manifestPath, manifest.title);
        manifest.description = this._localizeString(terminal, thisWebpack, compilation, manifestPath, manifest.description);
    }
    /**
     * Does extension-specific manifest processing.
     */
    _processExtensionsManifest(terminal, thisWebpack, compilation, manifestPath, manifest) {
        switch (manifest.extensionType) {
            case 'ListViewCommandSet':
                const commandSetManifest = manifest;
                for (const itemId in commandSetManifest.items) {
                    if (commandSetManifest.items.hasOwnProperty(itemId)) {
                        const item = commandSetManifest.items[itemId];
                        item.title = this._localizeString(terminal, thisWebpack, compilation, manifestPath, item.title);
                        if (item.ariaLabel) {
                            item.ariaLabel = this._localizeString(terminal, thisWebpack, compilation, manifestPath, item.ariaLabel);
                        }
                        item.iconImageUrl = IconHandler_1.IconHandler.processIconPath(this._options.terminal, compilation, manifestPath, item.iconImageUrl);
                    }
                }
                break;
            case 'Unknown':
            case 'ApplicationCustomizer':
            case 'FieldCustomizer':
                // No fields that require modification
                break;
        }
    }
    /**
     * Localizes a string with an ID in the form of $<path-to-loc-file>:<string-name>;
     * If the string to localize is not based on an id, it returns the input param untouched.
     */
    _localizeString(terminal, thisWebpack, compilation, manifestPath, stringToLocalize) {
        // If there is no id, assume the property is either not localized, or the localized values are
        // hardcoded.
        if (!stringToLocalize.id) {
            return stringToLocalize;
        }
        const EMPTY_LOCALIZED_STRING = {
            default: ''
        };
        const regex = /^(?:\$)([^:]+)(?:\:)(.+)(?:\;)$/; // Test $<path-to-loc-file>:<string-name>;
        const matches = stringToLocalize.id.match(regex);
        if ((matches === null || matches === void 0 ? void 0 : matches.length) === 3) {
            this._options.terminal.writeVerboseLine(`Localizing string '${matches[0]}'`);
            const locFilePath = matches[1];
            const stringName = matches[2];
            const locFileAbsolutePath = path.resolve(path.dirname(manifestPath), locFilePath);
            if (!node_core_library_1.FileSystem.exists(locFileAbsolutePath)) {
                compilation.errors.push(new thisWebpack.WebpackError(`Loc file missing from resolved path "${locFileAbsolutePath}". The manifest string will be missing.`));
                return EMPTY_LOCALIZED_STRING;
            }
            else {
                const localizedStrings = {};
                const normalizedSourceLocaleName = (0, normalizeLocaleName_1.normalizeLocaleName)(this._options.sourceLocaleName);
                const translationsForLocFile = this._options.tryGetLocFileTranslations(locFileAbsolutePath) || {};
                let locFile = translationsForLocFile === null || translationsForLocFile === void 0 ? void 0 : translationsForLocFile[this._options.sourceLocaleName];
                if (!locFile) {
                    locFile = this._parsedLocFileCache.get(locFileAbsolutePath);
                    if (!locFile) {
                        const parsedSourceFile = (0, localization_utilities_1.parseLocFile)({
                            filePath: locFileAbsolutePath,
                            content: node_core_library_1.FileSystem.readFile(locFileAbsolutePath),
                            terminal,
                            resxNewlineNormalization: node_core_library_1.NewlineKind.Lf,
                            ignoreMissingResxComments: false
                        });
                        locFile = {};
                        for (const [strName, { value }] of Object.entries(parsedSourceFile)) {
                            locFile[strName] = value;
                        }
                        this._parsedLocFileCache.set(locFileAbsolutePath, locFile);
                    }
                }
                if (!locFile[stringName]) {
                    compilation.errors.push(new thisWebpack.WebpackError(`Loc file "${locFileAbsolutePath}" doesn't contain a string with name "${stringName}".`));
                    return EMPTY_LOCALIZED_STRING;
                }
                else {
                    const selectedLocales = this._options.selectedLocales || Object.keys(translationsForLocFile);
                    for (const localeName of selectedLocales) {
                        const translatedLocFile = translationsForLocFile[localeName];
                        const normalizedLocaleName = (0, normalizeLocaleName_1.normalizeLocaleName)(localeName);
                        if (!translatedLocFile[stringName]) {
                            terminal.writeVerboseLine(`Loc file "${locFilePath}" for locale ${normalizedLocaleName} is either missing or is missing string ` +
                                `"${stringName}". Falling back to the string from ${normalizedSourceLocaleName}`);
                            localizedStrings[normalizedLocaleName] = locFile[stringName];
                        }
                        else {
                            localizedStrings[normalizedLocaleName] = translatedLocFile[stringName];
                        }
                    }
                    if (this._options.firstPassLocaleRemapping) {
                        LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, this._options.firstPassLocaleRemapping);
                    }
                    LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.LOCALE_MAPPING);
                    // Do this twice because some locales (like en-gb) appear both as values and as keys
                    LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.applyLocaleRemapping(localizedStrings, LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.LOCALE_MAPPING);
                    const defaultString = LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.findDefaultString(localizedStrings);
                    if (defaultString) {
                        localizedStrings.default = defaultString;
                    }
                    else {
                        compilation.errors.push(new thisWebpack.WebpackError(`Unable to select a default string for the localized string "${stringToLocalize.id}"`));
                        localizedStrings.default = '';
                    }
                    return localizedStrings;
                }
            }
        }
        else {
            compilation.errors.push(new thisWebpack.WebpackError(`String id '${stringToLocalize.id}' has wrong format. It is not $<moduleName>:<expression>;`));
            return EMPTY_LOCALIZED_STRING;
        }
    }
    _getEntryManifestModule(bundleName, runtimeChunk, assets) {
        if (runtimeChunk.localizedFiles) {
            // We have localized files, so this is a localized component
            return LocalizedManifestModuleProcessor_1.LocalizedManifestModuleProcessor.generateLocalizedManifestModule({
                bundleName,
                localizedPaths: runtimeChunk.localizedFiles,
                firstPassLocaleRemapping: this._options.firstPassLocaleRemapping,
                production: this._options.production,
                generateIntegrity: this._options.includeIntegrity,
                selectedLocales: this._options.selectedLocales,
                assets
            });
        }
        else {
            // No localized files, so this isn't a localized component
            const runtimeChunkPath = this._getRuntimeChunkInfo(bundleName, runtimeChunk, assets);
            const moduleConfiguration = {
                type: 'path',
                path: runtimeChunkPath
            };
            return moduleConfiguration;
        }
    }
    _populateLinkedExternalComponentInDependencyMap(dependencyName, dependencyId, dependencyVersion, isDirectDependency, dependenciesForAudit) {
        const nameWithVersion = dependencyVersion
            ? `${dependencyName}@${dependencyVersion}`
            : dependencyName;
        if (dependenciesForAudit.has(nameWithVersion)) {
            // A dependency name with this version already exists, skip
            return;
        }
        const existingAuditDependency = dependenciesForAudit.get(dependencyName);
        let nameToRecord = dependencyName;
        if (existingAuditDependency) {
            if (existingAuditDependency.componentVersion !== dependencyVersion) {
                // Remove and re-add this dependency to include the version
                dependenciesForAudit.delete(dependencyName);
                dependenciesForAudit.set(`${existingAuditDependency.componentName}@${existingAuditDependency.componentVersion}`, existingAuditDependency);
                nameToRecord = nameWithVersion;
            }
            else {
                // We've already recorded this dependency with this version
                return;
            }
        }
        if (!dependenciesForAudit.has(dependencyName)) {
            dependenciesForAudit.set(nameToRecord, {
                componentId: dependencyId,
                componentName: dependencyName,
                componentVersion: dependencyVersion,
                isDirectDependency
            });
            const referencedDependencyVersions = this._options.referencedProjects[dependencyId];
            if (!referencedDependencyVersions) {
                // If there is no project in referencedProjects, this is probably a non-standard external, so
                // it doesn't have conventional SPFx dependencies
                return;
            }
            let referencedDependency;
            if (dependencyVersion) {
                referencedDependency = referencedDependencyVersions[dependencyVersion];
                if (!referencedDependency) {
                    throw new Error(`Unable to find version "${dependencyVersion}" of component "${dependencyName}"`);
                }
            }
            else {
                const versions = Object.entries(referencedDependencyVersions);
                if (versions.length === 1) {
                    referencedDependency = versions[0][1];
                }
                else if (versions.length === 0) {
                    throw new Error(`No versions exist for dependency "${dependencyName}". This is not expected.`);
                }
                else {
                    throw new Error(`No version specified for "${dependencyName}" and multiple dependency versions exist.`);
                }
            }
            for (const [depName, dep] of Object.entries(referencedDependency.manifestData.loaderConfig.scriptResources)) {
                if (dep.type === 'component') {
                    const componentDependency = dep;
                    this._populateLinkedExternalComponentInDependencyMap(depName, componentDependency.id, componentDependency.version, false, dependenciesForAudit);
                }
            }
        }
    }
}
exports.ManifestPlugin = ManifestPlugin;
//# sourceMappingURL=ManifestPlugin.js.map