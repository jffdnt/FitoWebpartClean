"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebpackConfigurationGenerator = exports.COMMON_RULE_OPTIONS = exports.FILE_LOADER_RULE_TEST = exports.CONFIG_JSON_SYMBOL = exports.IS_SPFX_WEBPACK_CONFIGURATION_SYMBOL = exports.FILE_LOADER_EXTENSIONS = void 0;
// NodeJS
const path = __importStar(require("path"));
const webpack = __importStar(require("webpack"));
const os = __importStar(require("os"));
const crypto = __importStar(require("crypto"));
// Externals
const webpack5_module_minifier_plugin_1 = require("@rushstack/webpack5-module-minifier-plugin");
const module_minifier_1 = require("@rushstack/module-minifier");
const node_core_library_1 = require("@rushstack/node-core-library");
const set_webpack_public_path_plugin_1 = require("@rushstack/set-webpack-public-path-plugin");
const true_case_path_1 = require("true-case-path");
// Local
const CopyReleaseAssetsPlugin_1 = require("./webpackPlugins/CopyReleaseAssetsPlugin");
const WebpackStatsPlugin_1 = require("./webpackPlugins/WebpackStatsPlugin");
const AsyncComponentPlugin_1 = require("./webpackPlugins/AsyncComponentPlugin");
const CumulativeManifestProcessor_1 = require("../../spfxManifests/cumulativeManifestProcessor/CumulativeManifestProcessor");
const ExternalsProcessor_1 = require("../../spfxManifests/utilities/ExternalsProcessor");
const getFullHash_1 = require("../../spfxManifests/utilities/getFullHash");
const constants_1 = require("../../utilities/constants");
const ManifestPlugin_1 = require("../../spfxManifests/webpack/ManifestPlugin");
const VariableNameGenerator_1 = require("../../utilities/VariableNameGenerator");
/**
 * @public
 */
exports.FILE_LOADER_EXTENSIONS = [
    'jpg',
    'png',
    'woff',
    'woff2',
    'eot',
    'ttf',
    'svg',
    'gif',
    'dds',
    'cur',
    'webp',
    'mp4'
];
/**
 * @public
 */
exports.IS_SPFX_WEBPACK_CONFIGURATION_SYMBOL = Symbol('IS_SPFX_WEBPACK_CONFIGURATION');
/**
 * @public
 */
exports.CONFIG_JSON_SYMBOL = Symbol('CONFIG_JSON');
/**
 * @internal
 */
exports.FILE_LOADER_RULE_TEST = {
    or: exports.FILE_LOADER_EXTENSIONS.map(
    // eslint-disable-next-line @rushstack/security/no-unsafe-regexp
    (ext) => new RegExp(`\\.${node_core_library_1.Text.escapeRegExp(ext)}((\\?|\\#).+)?$`))
};
const ASSET_RESOURCE_RULE_OPTIONS = {
    type: 'asset/resource',
    generator: {
        filename: '[name]_[contenthash][ext]'
    }
};
/**
 * @internal
 */
exports.COMMON_RULE_OPTIONS = {
    dependency: {
        not: ['url']
    }
};
const VERSIONED_ASSETS_FOLDER_NAME = 'assets-versioned';
const LIBRARY_TARGET = 'amd';
const cssHashCache = new Map();
const DEFAULT_GENERATE_CSS_CLASS_NAME = (existingClassName, cssFilename, cssContent) => {
    let hash = cssHashCache.get(cssFilename);
    if (!hash) {
        hash = crypto.createHmac('sha1', cssFilename).update(cssContent).digest('hex').substring(0, 8);
        cssHashCache.set(cssFilename, hash);
    }
    return `${existingClassName}_${hash}`;
};
/**
 * @public
 */
class WebpackConfigurationGenerator {
    static async generateWebpackConfigurationAsync(options) {
        var _a, _b;
        WebpackConfigurationGenerator._validateEntries(options.configJson, options.folders.buildFolder);
        const terminal = options.terminal;
        const configBundleEntries = options.configJson.bundles || {};
        const distFolderName = path.basename(options.folders.outputFolder);
        //#region EXTERNAL COMPONENTS
        // Discover packages that should be externalized because they have manifests
        const cumulativeManifestProcessor = new CumulativeManifestProcessor_1.CumulativeManifestProcessor({
            terminal: options.terminal,
            rootPath: options.folders.buildFolder,
            tempFolderName: path.basename(options.folders.tempFolder),
            distFolderName: distFolderName,
            includeAssemblies: true
        });
        const referencedProjects = cumulativeManifestProcessor.discoverManifests(options.folders.buildFolder, options._useManifestsJsonForComponentDependencies
            ? CumulativeManifestProcessor_1.DependencyDiscoveryMode.shallow
            : CumulativeManifestProcessor_1.DependencyDiscoveryMode.deepSparseIgnoreFirstProject);
        const linkedExternals = new Map();
        // Add these projects to externalized packages
        for (const [manifestId, versionMap] of Object.entries(referencedProjects)) {
            for (const { packageName, isAssembly, manifestData: { version } } of Object.values(versionMap)) {
                if (packageName && !isAssembly) {
                    linkedExternals.set(packageName, {
                        id: manifestId,
                        name: packageName,
                        version: version
                    });
                }
            }
        }
        const nonStandardExternals = (0, ExternalsProcessor_1.getNonStandardExternals)(options.folders.buildFolder, referencedProjects);
        for (const [externalName, external] of nonStandardExternals) {
            linkedExternals.set(externalName, external);
        }
        const externalsKeys = new Set(linkedExternals.keys());
        if (options.configJson.externals) {
            for (const externalKey of Object.keys(options.configJson.externals)) {
                externalsKeys.add(externalKey);
            }
        }
        // Remove the specified linked externals to ensure they're bundled
        if ((_a = options.linkedExternalsToBundle) === null || _a === void 0 ? void 0 : _a.length) {
            for (const linkedExternalToBundle of options.linkedExternalsToBundle) {
                externalsKeys.delete(linkedExternalToBundle);
            }
        }
        // Don't list the project being built as an external
        externalsKeys.delete(options.projectPackageJson.name);
        //#endregion
        const configBundleEntriesCount = Object.keys(configBundleEntries).length;
        if (configBundleEntriesCount === 0) {
            terminal.writeWarningLine('No entries are defined, so no bundles will be produced.');
            return undefined;
        }
        terminal.writeVerboseLine(`${configBundleEntriesCount} entries specified.`);
        terminal.writeVerboseLine(`${externalsKeys.size} externals specified.`);
        const bundleEntries = [];
        const webpackEntries = {};
        const webpackUniqueNameParts = [];
        for (const [bundleName, configEntry] of Object.entries(configBundleEntries)) {
            const bundleEntry = {
                bundleName,
                components: {}
            };
            for (const componentEntry of configEntry.components) {
                const manifestData = await node_core_library_1.JsonFile.loadAsync(path.resolve(options.folders.buildFolder, componentEntry.manifest));
                // If the manifest version is "*", replace it with the package version. Do this here to make sure the
                //  bundle's name doesn't contain the "*" version
                if (manifestData.version === '*') {
                    const packageJson = node_core_library_1.PackageJsonLookup.instance.tryLoadPackageJsonFor(options.folders.buildFolder);
                    if (!packageJson) {
                        throw new Error(`Unable to find package.json for "${options.folders.buildFolder}"`);
                    }
                    // Remove pre-release name if any, because pre-release is not handled by SPFx yet.
                    const indexOfDelimiter = packageJson.version.indexOf('-');
                    const manifestVersion = indexOfDelimiter > 0 ? packageJson.version.substr(0, indexOfDelimiter) : packageJson.version;
                    manifestData.version = manifestVersion;
                }
                // Keep a counter of the manifests inside the bundle so we can set the exportName property in the produced
                //  manifest(s) and generate a JS file to bundle both components' entrypoints
                bundleEntry.components[manifestData.id] = {
                    ...componentEntry,
                    manifestData,
                    manifestPath: path.join(options.folders.buildFolder, componentEntry.manifest),
                    exportName: undefined
                };
                webpackUniqueNameParts.push(WebpackConfigurationGenerator.getComponentBundleId(manifestData));
            }
            const components = Object.values(bundleEntry.components);
            let entryImport;
            if (components.length === 1) {
                // Single component, just point to its entrypoint in the webpack config
                entryImport = await node_core_library_1.Import.resolveModuleAsync({
                    modulePath: components[0].entrypoint,
                    baseFolderPath: options.folders.buildFolder
                });
            }
            else {
                // Multiple components, we need to generate an entry to point the webpack config in the temp folder
                entryImport = await this._generateBundleEntrypointFileAsync({
                    bundleEntry,
                    buildFolder: options.folders.buildFolder,
                    tempFolder: options.folders.tempFolder
                });
            }
            webpackEntries[bundleName] = {
                import: entryImport,
                library: {
                    type: LIBRARY_TARGET,
                    name: webpackUniqueNameParts.length === 1 ? webpackUniqueNameParts[0] : undefined
                }
            };
            bundleEntries.push(bundleEntry);
        }
        let webpackUniqueName;
        if (webpackUniqueNameParts.length === 1) {
            // We're producing one bundle, so we can generate a simple name
            webpackUniqueName = webpackUniqueNameParts[0];
        }
        else {
            // There are multiple bundles. Because we need something unique for the webpack JSONP function, we'll just
            // concatenate the IDs and then hash them.
            webpackUniqueName = (0, getFullHash_1.getFullHash)(webpackUniqueNameParts.join(''));
        }
        const generateCssClassName = options.generateCssClassName || DEFAULT_GENERATE_CSS_CLASS_NAME;
        const simpleCssLoaderPath = WebpackConfigurationGenerator._requireResolveWithCorrectCase('@microsoft/sp-css-loader');
        const simpleCssLoaderOptions = {
            async: true,
            loadThemedStylesImportPath: options.loadThemedStylesImportPath,
            production: options.production
        };
        const cssLoaders = [
            {
                loader: simpleCssLoaderPath,
                options: simpleCssLoaderOptions
            }
        ];
        const moduleScssCssLoaders = [
            {
                loader: simpleCssLoaderPath,
                options: {
                    ...simpleCssLoaderOptions,
                    generateCssClassName: generateCssClassName
                }
            }
        ];
        const outputFilenameParts = ['[name]'];
        if (options.getLocalization) {
            outputFilenameParts.push('_[locale]');
        }
        if (!options.serveMode && options.production) {
            // The "contenthash" template is the hash of file contents and is preferred over "hash".
            // Serve mode does not support "contenthash" and 3rd party developers may use deployed
            // manifests files for local development, which precludes the use of dynamic hashes.
            outputFilenameParts.push('_[contenthash]');
        }
        const devtool = options.production
            ? options.buildSourceMaps
                ? 'hidden-source-map'
                : undefined
            : // SPFx always builds source maps in non-production builds
                'source-map';
        outputFilenameParts.push('.js');
        const outputFilename = outputFilenameParts.join('');
        const config = {
            [exports.IS_SPFX_WEBPACK_CONFIGURATION_SYMBOL]: true,
            [exports.CONFIG_JSON_SYMBOL]: options.configJson,
            module: {
                rules: [
                    // Allow importing JS files that don't have explicit extensions
                    {
                        ...ASSET_RESOURCE_RULE_OPTIONS,
                        dependency: 'url',
                        test: []
                    },
                    {
                        ...exports.COMMON_RULE_OPTIONS,
                        test: /\.js$/,
                        resolve: {
                            fullySpecified: false
                        }
                    },
                    {
                        ...exports.COMMON_RULE_OPTIONS,
                        use: moduleScssCssLoaders,
                        test: /\.module\.scss\.css$/i
                    },
                    {
                        ...exports.COMMON_RULE_OPTIONS,
                        use: cssLoaders,
                        test: /(?<!\.module(\.scss?))\.css$/
                    },
                    {
                        ...exports.COMMON_RULE_OPTIONS,
                        ...ASSET_RESOURCE_RULE_OPTIONS,
                        test: exports.FILE_LOADER_RULE_TEST
                    },
                    {
                        ...exports.COMMON_RULE_OPTIONS,
                        test: /\.html$/,
                        use: {
                            loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('html-loader')
                        }
                    }
                ],
                noParse: [/\.map$/]
            },
            resolve: {
                alias: {},
                modules: ['node_modules'],
                extensions: ['.wasm', '.mjs', '.js', '.json', '.css', '.jsx']
            },
            context: options.folders.buildFolder,
            devtool,
            mode: options.production ? 'production' : 'development',
            entry: webpackEntries,
            externals: Array.from(externalsKeys),
            output: {
                hashFunction: 'md5',
                chunkFilename: `chunk.${outputFilename}`,
                filename: outputFilename,
                chunkLoadingGlobal: `webpackJsonp_${webpackUniqueName}`,
                libraryTarget: LIBRARY_TARGET,
                uniqueName: webpackUniqueName,
                path: options.folders.outputFolder,
                devtoolModuleFilenameTemplate: 'webpack:///../[resource-path]',
                devtoolFallbackModuleFilenameTemplate: 'webpack:///../[resource-path]?[contenthash]',
                crossOriginLoading: options.crossOriginLoading !== false && 'anonymous'
            },
            optimization: {
                moduleIds: 'deterministic',
                // Always enable these since they help reduce output sizes in a readable manner.
                usedExports: true,
                sideEffects: true,
                removeEmptyChunks: true,
                // TODO: turn this on when weback5-localization-plugin can suppress RealHashPlugin re-processing files.
                realContentHash: false
            },
            performance: {
                hints: false
            }
        };
        const plugins = [
            new set_webpack_public_path_plugin_1.SetPublicPathCurrentScriptPlugin(),
            new webpack.DefinePlugin({
                DEBUG: !options.production,
                DEPRECATED_UNIT_TEST: false,
                'process.env': {
                    NODE_ENV: options.production ? '"production"' : '"development"'
                }
            })
        ];
        config.plugins = plugins;
        // Stats are incredibly expensive to write and generate.
        // Leave this option behind a flag for generation
        if (options.emitStats) {
            plugins.push(new WebpackStatsPlugin_1.WebpackStatsPlugin({
                dropPath: path.resolve(options.folders.releaseFolder, 'webpack-stats', `${path.basename(options.folders.buildFolder)}.stats.json`)
            }));
        }
        if (!options.disableAsyncComponentLoading) {
            const asyncComponentPluginExternalComponents = [];
            for (const { id: componentId, name: componentName, version: componentVersion } of linkedExternals.values()) {
                asyncComponentPluginExternalComponents.push({
                    componentId,
                    componentName,
                    componentVersion
                });
            }
            plugins.push(new AsyncComponentPlugin_1.AsyncComponentPlugin({
                externalComponents: asyncComponentPluginExternalComponents
            }));
        }
        let tryGetLocFileTranslations = () => undefined;
        let localizedData = {};
        let selectedLocales = new Set([constants_1.DEFAULT_LOCALE]);
        if (options.getLocalization) {
            const localizationPackage = options.getLocalization();
            localizedData = await localizationPackage.getProjectLocalizedStringsAsync();
            tryGetLocFileTranslations = localizationPackage.getLocFileTranslations.bind(localizationPackage);
            const localizedDataKeys = Object.keys(localizedData);
            if (localizedDataKeys.length > 0) {
                if (options.selectedLocales) {
                    for (const selectedLocale of options.selectedLocales) {
                        if (selectedLocale !== constants_1.DEFAULT_LOCALE && !localizedData.hasOwnProperty(selectedLocale)) {
                            throw new Error(`The selected locale (${selectedLocale}) is not present in the localized data.`);
                        }
                    }
                    selectedLocales = new Set([constants_1.DEFAULT_LOCALE, ...options.selectedLocales]);
                }
                else if (options.production) {
                    selectedLocales = new Set([constants_1.DEFAULT_LOCALE, ...localizedDataKeys]);
                }
            }
            const { localizationPlugin, stringsLoaders } = await localizationPackage.getLocalizationConfigurationAsync(selectedLocales);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            config.module.rules.push(...stringsLoaders);
            plugins.push(localizationPlugin);
        }
        let serveConfig = {};
        try {
            serveConfig = await node_core_library_1.JsonFile.loadAsync(path.join(options.folders.buildFolder, 'config', 'serve.json'));
        }
        catch (e) {
            if (!node_core_library_1.FileSystem.isNotExistError(e)) {
                throw e;
            }
        }
        const debugBaseUrl = `${serveConfig.https ? 'https' : 'http'}://${serveConfig.hostname || 'localhost'}:${serveConfig.port || 4321}/${distFolderName}/`;
        let cdnBaseUrl;
        try {
            const writeManifestsConfig = await node_core_library_1.JsonFile.loadAsync(path.join(options.folders.buildFolder, 'config', 'write-manifests.json'));
            cdnBaseUrl = writeManifestsConfig.cdnBasePath;
        }
        catch (e) {
            if (!node_core_library_1.FileSystem.isFileDoesNotExistError(e)) {
                throw e;
            }
        }
        plugins.push(new ManifestPlugin_1.ManifestPlugin({
            terminal,
            selectedLocales,
            production: options.production,
            includeIntegrity: options._includeIntegrityInManifestPaths,
            sourceLocaleName: constants_1.DEFAULT_LOCALE,
            bundleEntries,
            internalModuleBaseUrls: cdnBaseUrl ? [cdnBaseUrl] : [],
            debugInternalModuleBaseUrls: [debugBaseUrl],
            linkedExternals,
            referencedProjects,
            cumulativeManifestProcessor,
            useManifestsJsonForComponentDependencies: options._useManifestsJsonForComponentDependencies,
            tryGetLocFileTranslations,
            asyncOnlyDependencies: {
                asyncOnlyDependencyNames: options.configJson.asyncComponents || [],
                violationsAsErrors: options.production
            },
            componentDependenciesAuditDropPath: path.join(options.folders.releaseFolder, 'component-dependency-audit', `${path.basename(options.folders.buildFolder)}.json`),
            manifestsJsFileMetadata: options._manifestsJsFileMetadata
        }));
        if (options.production) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            config.optimization.minimize = true;
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            config.optimization.minimizer = [
                new webpack5_module_minifier_plugin_1.ModuleMinifierPlugin({
                    minifier: new module_minifier_1.WorkerPoolMinifier({
                        // Cap the number of worker processes to avoid CPU saturation.
                        maxThreads: Math.min(8, os.cpus().length),
                        terserOptions: {
                            compress: {
                                passes: 3
                            },
                            mangle: true,
                            output: {
                                comments: false,
                                // eslint-disable-next-line @typescript-eslint/naming-convention
                                wrap_func_args: false
                            }
                        }
                    }),
                    sourceMap: !!devtool
                })
            ];
        }
        if (devtool) {
            const defaultFilter = (url, resourcePath) => {
                return resourcePath.indexOf('node_modules') === -1;
            };
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            config.module.rules.push({
                test: /\.js$/,
                enforce: 'pre',
                use: {
                    loader: WebpackConfigurationGenerator._requireResolveWithCorrectCase('source-map-loader'),
                    options: {
                        filterSourceMappingUrl: (_b = options.sourceMapUrlFilter) !== null && _b !== void 0 ? _b : defaultFilter
                    }
                }
            });
        }
        // Always produce the release/ folder
        plugins.push(new CopyReleaseAssetsPlugin_1.CopyReleaseAssetsPlugin({
            releasePath: options.folders.releaseFolder,
            isDebug: !options.production,
            assetsFolderName: options.assetsAreVersioned ? VERSIONED_ASSETS_FOLDER_NAME : undefined,
            manifestsFolderName: options.releaseManifestFolderName,
            releaseMapFiles: options.releaseMapFiles
        }));
        return config;
    }
    /**
     * @internal
     */
    static getComponentBundleId(manifest) {
        return `${manifest.id}_${manifest.version}`;
    }
    /**
     * Writes the entrypoint file to the temp directory and returns the path to the file.
     */
    static async _generateBundleEntrypointFileAsync(options) {
        const entrypointFileFolderPath = `${options.tempFolder}/bundle-entries`;
        const filePath = `${entrypointFileFolderPath}/${options.bundleEntry.bundleName}.js`;
        const variableNameGenerator = await VariableNameGenerator_1.VariableNameGenerator.initializeAsync();
        const fileLines = [];
        for (const bundleComponent of Object.values(options.bundleEntry.components)) {
            const fullEntrypointPath = await node_core_library_1.Import.resolveModuleAsync({
                modulePath: bundleComponent.entrypoint,
                baseFolderPath: options.buildFolder
            });
            const relativeEntrypointPath = path.relative(entrypointFileFolderPath, fullEntrypointPath);
            const exportName = variableNameGenerator.getNextVariableName();
            bundleComponent.exportName = exportName;
            fileLines.push(`// ${bundleComponent.manifestData.alias}`);
            fileLines.push(`export * as ${exportName} from '${node_core_library_1.Path.convertToSlashes(relativeEntrypointPath)}';`);
            fileLines.push('');
        }
        const fileContents = fileLines.join('\n');
        await node_core_library_1.FileSystem.writeFileAsync(filePath, fileContents, { ensureFolderExists: true });
        return filePath;
    }
    static _requireResolveWithCorrectCase(packageName) {
        const resolveResult = node_core_library_1.Import.resolvePackage({ packageName, baseFolderPath: __dirname });
        return (0, true_case_path_1.trueCasePathSync)(resolveResult);
    }
    static _validateEntries(configJson, rootPath) {
        if (configJson.bundles) {
            const entrypointPaths = new Set();
            const manifestPaths = new Set();
            for (const [, bundleEntry] of Object.entries(configJson.bundles)) {
                for (const component of bundleEntry.components) {
                    const entrypointPath = node_core_library_1.Import.resolveModule({
                        modulePath: component.entrypoint,
                        baseFolderPath: rootPath
                    }).toUpperCase();
                    if (entrypointPaths.has(entrypointPath)) {
                        throw new Error(`Entry path "${entrypointPath}" occurs in multiple config.json components. This is not supported.`);
                    }
                    else {
                        entrypointPaths.add(entrypointPath);
                    }
                    const manifestPath = path.resolve(path.join(rootPath, component.manifest)).toUpperCase();
                    if (manifestPaths.has(manifestPath)) {
                        throw new Error(`Manifest path "${manifestPath}" occurs in multiple config.json components. This is not ` +
                            'supported.');
                    }
                    else {
                        manifestPaths.add(manifestPath);
                    }
                }
            }
        }
    }
}
exports.WebpackConfigurationGenerator = WebpackConfigurationGenerator;
//# sourceMappingURL=WebpackConfigurationGenerator.js.map