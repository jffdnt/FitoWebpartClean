"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CopyReleaseAssetsPlugin = void 0;
const path_1 = __importDefault(require("path"));
const PLUGIN_NAME = 'copy-release-assets';
const IGNORED_FILE_EXTENSIONS_DEBUG = ['.stats.json', '.stats.html'];
const IGNORED_FILE_EXTENSIONS_PRODUCTION = [...IGNORED_FILE_EXTENSIONS_DEBUG];
const DEFAULT_ASSETS_FOLDER_NAME = 'assets';
const MANIFESTS_FOLDER_NAME = 'manifests';
class CopyReleaseAssetsPlugin {
    constructor(options) {
        this._options = options;
        if (!this._options.releaseMapFiles) {
            IGNORED_FILE_EXTENSIONS_PRODUCTION.push('.map');
        }
    }
    apply(compiler) {
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {
            const thisWebpack = compiler.webpack;
            compilation.hooks.processAssets.tapPromise({
                stage: thisWebpack.Compilation.PROCESS_ASSETS_STAGE_REPORT + 1,
                name: PLUGIN_NAME
            }, async () => {
                const { releasePath, isDebug, assetsFolderName = DEFAULT_ASSETS_FOLDER_NAME, manifestsFolderName = MANIFESTS_FOLDER_NAME } = this._options;
                const assetsReleasePath = `${releasePath}/${assetsFolderName}`;
                const manifestsReleasePath = `${releasePath}/${manifestsFolderName}`;
                const relativeAssetsReleasePath = path_1.default.relative(
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                compiler.options.output.path, assetsReleasePath);
                const relativeManifestsReleasePath = path_1.default.relative(
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                compiler.options.output.path, manifestsReleasePath);
                const ignoredFileExtensions = isDebug
                    ? IGNORED_FILE_EXTENSIONS_DEBUG
                    : IGNORED_FILE_EXTENSIONS_PRODUCTION;
                for (const [assetName, assetSource] of Object.entries(compilation.assets)) {
                    let shouldCopyAssetToRelease = true;
                    for (const ignoredExtension of ignoredFileExtensions) {
                        if (assetName.endsWith(ignoredExtension)) {
                            shouldCopyAssetToRelease = false;
                            break;
                        }
                    }
                    if (shouldCopyAssetToRelease) {
                        const releaseManifestVariant = assetSource.releaseManifest;
                        if (releaseManifestVariant) {
                            // This is a manifest
                            compilation.emitAsset(`${relativeManifestsReleasePath}/${assetName}`, new thisWebpack.sources.RawSource(releaseManifestVariant));
                        }
                        else {
                            // This isn't a manifest
                            compilation.emitAsset(`${relativeAssetsReleasePath}/${assetName}`, assetSource);
                        }
                    }
                }
            });
        });
    }
}
exports.CopyReleaseAssetsPlugin = CopyReleaseAssetsPlugin;
//# sourceMappingURL=CopyReleaseAssetsPlugin.js.map