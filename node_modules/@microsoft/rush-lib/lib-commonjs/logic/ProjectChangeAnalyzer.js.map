{"version":3,"file":"ProjectChangeAnalyzer.js","sourceRoot":"","sources":["../../src/logic/ProjectChangeAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as crypto from 'crypto';\nimport ignore, { type Ignore } from 'ignore';\n\nimport {\n  getRepoChanges,\n  getRepoRoot,\n  getRepoStateAsync,\n  type IFileDiffStatus\n} from '@rushstack/package-deps-hash';\nimport { Path, FileSystem, Async } from '@rushstack/node-core-library';\nimport type { ITerminal } from '@rushstack/terminal';\n\nimport type { RushConfiguration } from '../api/RushConfiguration';\nimport { RushProjectConfiguration } from '../api/RushProjectConfiguration';\nimport { Git } from './Git';\nimport { BaseProjectShrinkwrapFile } from './base/BaseProjectShrinkwrapFile';\nimport type { RushConfigurationProject } from '../api/RushConfigurationProject';\nimport { RushConstants } from './RushConstants';\nimport type { LookupByPath } from '@rushstack/lookup-by-path';\nimport { PnpmShrinkwrapFile } from './pnpm/PnpmShrinkwrapFile';\nimport { UNINITIALIZED } from '../utilities/Utilities';\n\n/**\n * @beta\n */\nexport interface IGetChangedProjectsOptions {\n  targetBranchName: string;\n  terminal: ITerminal;\n  shouldFetch?: boolean;\n\n  /**\n   * If set to `true`, consider a project's external dependency installation layout as defined in the\n   * package manager lockfile when determining if it has changed.\n   */\n  includeExternalDependencies: boolean;\n\n  /**\n   * If set to `true` apply the `incrementalBuildIgnoredGlobs` property in a project's `rush-project.json`\n   * and exclude matched files from change detection.\n   */\n  enableFiltering: boolean;\n}\n\ninterface IGitState {\n  gitPath: string;\n  hashes: Map<string, string>;\n  rootDir: string;\n}\n\n/**\n * @internal\n */\nexport interface IRawRepoState {\n  projectState: Map<RushConfigurationProject, Map<string, string>> | undefined;\n  rootDir: string;\n  rawHashes: Map<string, string>;\n}\n\n/**\n * @beta\n */\nexport class ProjectChangeAnalyzer {\n  /**\n   * UNINITIALIZED === we haven't looked\n   * undefined === data isn't available (i.e. - git isn't present)\n   */\n  private _data: IRawRepoState | UNINITIALIZED | undefined = UNINITIALIZED;\n  private readonly _filteredData: Map<RushConfigurationProject, Map<string, string>> = new Map();\n  private readonly _projectStateCache: Map<RushConfigurationProject, string> = new Map();\n  private readonly _rushConfiguration: RushConfiguration;\n  private readonly _git: Git;\n\n  public constructor(rushConfiguration: RushConfiguration) {\n    this._rushConfiguration = rushConfiguration;\n    this._git = new Git(this._rushConfiguration);\n  }\n\n  /**\n   * Try to get a list of the specified project's dependencies and their hashes.\n   *\n   * @remarks\n   * If the data can't be generated (i.e. - if Git is not present) this returns undefined.\n   *\n   * @internal\n   */\n  public async _tryGetProjectDependenciesAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<Map<string, string> | undefined> {\n    // Check the cache for any existing data\n    let filteredProjectData: Map<string, string> | undefined = this._filteredData.get(project);\n    if (filteredProjectData) {\n      return filteredProjectData;\n    }\n\n    const data: IRawRepoState | undefined = await this._ensureInitializedAsync(terminal);\n\n    if (!data) {\n      return undefined;\n    }\n\n    const { projectState, rootDir } = data;\n\n    if (projectState === undefined) {\n      return undefined;\n    }\n\n    const unfilteredProjectData: Map<string, string> | undefined = projectState.get(project);\n    if (!unfilteredProjectData) {\n      throw new Error(`Project \"${project.packageName}\" does not exist in the current Rush configuration.`);\n    }\n\n    filteredProjectData = await this._filterProjectDataAsync(\n      project,\n      unfilteredProjectData,\n      rootDir,\n      terminal\n    );\n\n    this._filteredData.set(project, filteredProjectData);\n    return filteredProjectData;\n  }\n\n  /**\n   * @internal\n   */\n  public async _ensureInitializedAsync(terminal: ITerminal): Promise<IRawRepoState | undefined> {\n    if (this._data === UNINITIALIZED) {\n      this._data = await this._getDataAsync(terminal);\n    }\n\n    return this._data;\n  }\n\n  /**\n   * The project state hash is calculated in the following way:\n   * - Project dependencies are collected (see ProjectChangeAnalyzer.getPackageDeps)\n   *   - If project dependencies cannot be collected (i.e. - if Git isn't available),\n   *     this function returns `undefined`\n   * - The (path separator normalized) repo-root-relative dependencies' file paths are sorted\n   * - A SHA1 hash is created and each (sorted) file path is fed into the hash and then its\n   *   Git SHA is fed into the hash\n   * - A hex digest of the hash is returned\n   *\n   * @internal\n   */\n  public async _tryGetProjectStateHashAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<string | undefined> {\n    let projectState: string | undefined = this._projectStateCache.get(project);\n    if (!projectState) {\n      const packageDeps: Map<string, string> | undefined = await this._tryGetProjectDependenciesAsync(\n        project,\n        terminal\n      );\n\n      if (!packageDeps) {\n        return undefined;\n      } else {\n        const sortedPackageDepsFiles: string[] = Array.from(packageDeps.keys()).sort();\n        const hash: crypto.Hash = crypto.createHash('sha1');\n        for (const packageDepsFile of sortedPackageDepsFiles) {\n          hash.update(packageDepsFile);\n          hash.update(RushConstants.hashDelimiter);\n          hash.update(packageDeps.get(packageDepsFile)!);\n          hash.update(RushConstants.hashDelimiter);\n        }\n\n        projectState = hash.digest('hex');\n        this._projectStateCache.set(project, projectState);\n      }\n    }\n\n    return projectState;\n  }\n\n  public async _filterProjectDataAsync<T>(\n    project: RushConfigurationProject,\n    unfilteredProjectData: Map<string, T>,\n    rootDir: string,\n    terminal: ITerminal\n  ): Promise<Map<string, T>> {\n    const ignoreMatcher: Ignore | undefined = await this._getIgnoreMatcherForProjectAsync(project, terminal);\n    if (!ignoreMatcher) {\n      return unfilteredProjectData;\n    }\n\n    const projectKey: string = path.relative(rootDir, project.projectFolder);\n    const projectKeyLength: number = projectKey.length + 1;\n\n    // At this point, `filePath` is guaranteed to start with `projectKey`, so\n    // we can safely slice off the first N characters to get the file path relative to the\n    // root of the project.\n    const filteredProjectData: Map<string, T> = new Map<string, T>();\n    for (const [filePath, value] of unfilteredProjectData) {\n      const relativePath: string = filePath.slice(projectKeyLength);\n      if (!ignoreMatcher.ignores(relativePath)) {\n        // Add the file path to the filtered data if it is not ignored\n        filteredProjectData.set(filePath, value);\n      }\n    }\n    return filteredProjectData;\n  }\n\n  /**\n   * Gets a list of projects that have changed in the current state of the repo\n   * when compared to the specified branch, optionally taking the shrinkwrap and settings in\n   * the rush-project.json file into consideration.\n   */\n  public async getChangedProjectsAsync(\n    options: IGetChangedProjectsOptions\n  ): Promise<Set<RushConfigurationProject>> {\n    const { _rushConfiguration: rushConfiguration } = this;\n\n    const { targetBranchName, terminal, includeExternalDependencies, enableFiltering, shouldFetch } = options;\n\n    const gitPath: string = this._git.getGitPathOrThrow();\n    const repoRoot: string = getRepoRoot(rushConfiguration.rushJsonFolder);\n\n    // if the given targetBranchName is a commit, we assume it is the merge base\n    const IsTargetBranchACommit: boolean = await this._git.determineIfRefIsACommitAsync(targetBranchName);\n    const mergeCommit: string = IsTargetBranchACommit\n      ? targetBranchName\n      : await this._git.getMergeBaseAsync(targetBranchName, terminal, shouldFetch);\n\n    const repoChanges: Map<string, IFileDiffStatus> = getRepoChanges(repoRoot, mergeCommit, gitPath);\n\n    const changedProjects: Set<RushConfigurationProject> = new Set();\n\n    if (includeExternalDependencies) {\n      // Even though changing the installed version of a nested dependency merits a change file,\n      // ignore lockfile changes for `rush change` for the moment\n\n      const currentVariant: string | undefined =\n        await this._rushConfiguration.getCurrentlyInstalledVariantAsync();\n      const fullShrinkwrapPath: string =\n        rushConfiguration.defaultSubspace.getCommittedShrinkwrapFilePath(currentVariant);\n\n      const relativeShrinkwrapFilePath: string = Path.convertToSlashes(\n        path.relative(repoRoot, fullShrinkwrapPath)\n      );\n      const shrinkwrapStatus: IFileDiffStatus | undefined = repoChanges.get(relativeShrinkwrapFilePath);\n\n      if (shrinkwrapStatus) {\n        if (shrinkwrapStatus.status !== 'M') {\n          terminal.writeLine(`Lockfile was created or deleted. Assuming all projects are affected.`);\n          return new Set(rushConfiguration.projects);\n        }\n\n        const { packageManager } = rushConfiguration;\n\n        if (packageManager === 'pnpm') {\n          const currentShrinkwrap: PnpmShrinkwrapFile | undefined =\n            PnpmShrinkwrapFile.loadFromFile(fullShrinkwrapPath);\n\n          if (!currentShrinkwrap) {\n            throw new Error(`Unable to obtain current shrinkwrap file.`);\n          }\n\n          const oldShrinkwrapText: string = await this._git.getBlobContentAsync({\n            // <ref>:<path> syntax: https://git-scm.com/docs/gitrevisions\n            blobSpec: `${mergeCommit}:${relativeShrinkwrapFilePath}`,\n            repositoryRoot: repoRoot\n          });\n          const oldShrinkWrap: PnpmShrinkwrapFile = PnpmShrinkwrapFile.loadFromString(oldShrinkwrapText);\n\n          for (const project of rushConfiguration.projects) {\n            if (\n              currentShrinkwrap\n                .getProjectShrinkwrap(project)\n                .hasChanges(oldShrinkWrap.getProjectShrinkwrap(project))\n            ) {\n              changedProjects.add(project);\n            }\n          }\n        } else {\n          terminal.writeLine(\n            `Lockfile has changed and lockfile content comparison is only supported for pnpm. Assuming all projects are affected.`\n          );\n          return new Set(rushConfiguration.projects);\n        }\n      }\n    }\n\n    const changesByProject: Map<RushConfigurationProject, Map<string, IFileDiffStatus>> = new Map();\n    const lookup: LookupByPath<RushConfigurationProject> =\n      rushConfiguration.getProjectLookupForRoot(repoRoot);\n\n    for (const [file, diffStatus] of repoChanges) {\n      const project: RushConfigurationProject | undefined = lookup.findChildPath(file);\n      if (project) {\n        if (changedProjects.has(project)) {\n          // Lockfile changes cannot be ignored via rush-project.json\n          continue;\n        }\n\n        if (enableFiltering) {\n          let projectChanges: Map<string, IFileDiffStatus> | undefined = changesByProject.get(project);\n          if (!projectChanges) {\n            projectChanges = new Map();\n            changesByProject.set(project, projectChanges);\n          }\n          projectChanges.set(file, diffStatus);\n        } else {\n          changedProjects.add(project);\n        }\n      }\n    }\n\n    if (enableFiltering) {\n      // Reading rush-project.json may be problematic if, e.g. rush install has not yet occurred and rigs are in use\n      await Async.forEachAsync(\n        changesByProject,\n        async ([project, projectChanges]) => {\n          const filteredChanges: Map<string, IFileDiffStatus> = await this._filterProjectDataAsync(\n            project,\n            projectChanges,\n            repoRoot,\n            terminal\n          );\n\n          if (filteredChanges.size > 0) {\n            changedProjects.add(project);\n          }\n        },\n        { concurrency: 10 }\n      );\n    }\n\n    return changedProjects;\n  }\n\n  private async _getDataAsync(terminal: ITerminal): Promise<IRawRepoState> {\n    const repoState: IGitState | undefined = await this._getRepoDepsAsync(terminal);\n    if (!repoState) {\n      // Mark as resolved, but no data\n      return {\n        projectState: undefined,\n        rootDir: this._rushConfiguration.rushJsonFolder,\n        rawHashes: new Map()\n      };\n    }\n\n    const lookup: LookupByPath<RushConfigurationProject> = this._rushConfiguration.getProjectLookupForRoot(\n      repoState.rootDir\n    );\n    const projectHashDeps: Map<RushConfigurationProject, Map<string, string>> = new Map();\n\n    for (const project of this._rushConfiguration.projects) {\n      projectHashDeps.set(project, new Map());\n    }\n\n    const { hashes: repoDeps, rootDir } = repoState;\n\n    // Currently, only pnpm handles project shrinkwraps\n    if (this._rushConfiguration.packageManager !== 'pnpm') {\n      const currentVariant: string | undefined =\n        await this._rushConfiguration.getCurrentlyInstalledVariantAsync();\n      // Add the shrinkwrap file to every project's dependencies\n      const shrinkwrapFile: string = Path.convertToSlashes(\n        path.relative(\n          rootDir,\n          this._rushConfiguration.defaultSubspace.getCommittedShrinkwrapFilePath(currentVariant)\n        )\n      );\n\n      const shrinkwrapHash: string | undefined = repoDeps.get(shrinkwrapFile);\n\n      for (const projectDeps of projectHashDeps.values()) {\n        if (shrinkwrapHash) {\n          projectDeps.set(shrinkwrapFile, shrinkwrapHash);\n        }\n      }\n    }\n\n    // Sort each project folder into its own package deps hash\n    for (const [filePath, fileHash] of repoDeps) {\n      // lookups in findChildPath are O(K)\n      // K being the maximum folder depth of any project in rush.json (usually on the order of 3)\n      const owningProject: RushConfigurationProject | undefined = lookup.findChildPath(filePath);\n\n      if (owningProject) {\n        const owningProjectHashDeps: Map<string, string> = projectHashDeps.get(owningProject)!;\n        owningProjectHashDeps.set(filePath, fileHash);\n      }\n    }\n\n    return {\n      projectState: projectHashDeps,\n      rootDir,\n      rawHashes: repoState.hashes\n    };\n  }\n\n  private async _getIgnoreMatcherForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<Ignore | undefined> {\n    const incrementalBuildIgnoredGlobs: ReadonlyArray<string> | undefined =\n      await RushProjectConfiguration.tryLoadIgnoreGlobsForProjectAsync(project, terminal);\n\n    if (incrementalBuildIgnoredGlobs && incrementalBuildIgnoredGlobs.length) {\n      const ignoreMatcher: Ignore = ignore();\n      ignoreMatcher.add(incrementalBuildIgnoredGlobs as string[]);\n      return ignoreMatcher;\n    }\n  }\n\n  private async _getRepoDepsAsync(terminal: ITerminal): Promise<IGitState | undefined> {\n    try {\n      const gitPath: string = this._git.getGitPathOrThrow();\n\n      if (this._git.isPathUnderGitWorkingTree()) {\n        // Do not use getGitInfo().root; it is the root of the *primary* worktree, not the *current* one.\n        const rootDir: string = getRepoRoot(this._rushConfiguration.rushJsonFolder, gitPath);\n        // Load the package deps hash for the whole repository\n        // Include project shrinkwrap files as part of the computation\n        const additionalFilesToHash: string[] = [];\n\n        if (this._rushConfiguration.packageManager === 'pnpm') {\n          await Async.forEachAsync(\n            this._rushConfiguration.projects,\n            async (project: RushConfigurationProject) => {\n              const projectShrinkwrapFilePath: string =\n                BaseProjectShrinkwrapFile.getFilePathForProject(project);\n              if (!(await FileSystem.existsAsync(projectShrinkwrapFilePath))) {\n                // Missing shrinkwrap of subspace project is allowed because subspace projects can be partial installed\n                if (this._rushConfiguration.subspacesFeatureEnabled) {\n                  return;\n                }\n                throw new Error(\n                  `A project dependency file (${projectShrinkwrapFilePath}) is missing. You may need to run ` +\n                    '\"rush install\" or \"rush update\".'\n                );\n              }\n              const relativeProjectShrinkwrapFilePath: string = Path.convertToSlashes(\n                path.relative(rootDir, projectShrinkwrapFilePath)\n              );\n              additionalFilesToHash.push(relativeProjectShrinkwrapFilePath);\n            }\n          );\n        }\n\n        const hashes: Map<string, string> = await getRepoStateAsync(rootDir, additionalFilesToHash, gitPath);\n        return {\n          gitPath,\n          hashes,\n          rootDir\n        };\n      } else {\n        return undefined;\n      }\n    } catch (e) {\n      // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about\n      // the state of the files in the repo. This can happen if the environment doesn't have Git.\n      terminal.writeWarningLine(\n        `Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`\n      );\n\n      return undefined;\n    }\n  }\n}\n"]}