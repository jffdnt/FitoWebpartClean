"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectBuildCache = void 0;
const path = __importStar(require("path"));
const crypto = __importStar(require("crypto"));
const node_core_library_1 = require("@rushstack/node-core-library");
const RushConstants_1 = require("../RushConstants");
const TarExecutable_1 = require("../../utilities/TarExecutable");
const EnvironmentConfiguration_1 = require("../../api/EnvironmentConfiguration");
class ProjectBuildCache {
    constructor(cacheId, options) {
        const { buildCacheConfiguration: { localCacheProvider, cloudCacheProvider, buildCacheEnabled, cacheWriteEnabled }, project, projectOutputFolderNames, additionalProjectOutputFilePaths } = options;
        this._project = project;
        this._localBuildCacheProvider = localCacheProvider;
        this._cloudBuildCacheProvider = cloudCacheProvider;
        this._buildCacheEnabled = buildCacheEnabled;
        this._cacheWriteEnabled = cacheWriteEnabled;
        this._projectOutputFolderNames = projectOutputFolderNames || [];
        this._additionalProjectOutputFilePaths = additionalProjectOutputFilePaths || [];
        this._cacheId = cacheId;
    }
    static _tryGetTarUtility(terminal) {
        if (ProjectBuildCache._tarUtilityPromise === null) {
            ProjectBuildCache._tarUtilityPromise = TarExecutable_1.TarExecutable.tryInitializeAsync(terminal);
        }
        return ProjectBuildCache._tarUtilityPromise;
    }
    get cacheId() {
        return this._cacheId;
    }
    static async tryGetProjectBuildCacheAsync(options) {
        const cacheId = await ProjectBuildCache._getCacheIdAsync(options);
        return new ProjectBuildCache(cacheId, options);
    }
    async tryRestoreFromCacheAsync(terminal, specifiedCacheId) {
        const cacheId = specifiedCacheId || this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        if (!this._buildCacheEnabled) {
            // Skip reading local and cloud build caches, without any noise
            return false;
        }
        let localCacheEntryPath = await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);
        let cacheEntryBuffer;
        let updateLocalCacheSuccess;
        if (!localCacheEntryPath && this._cloudBuildCacheProvider) {
            terminal.writeVerboseLine('This project was not found in the local build cache. Querying the cloud build cache.');
            cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(terminal, cacheId);
            if (cacheEntryBuffer) {
                try {
                    localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
                    updateLocalCacheSuccess = true;
                }
                catch (e) {
                    updateLocalCacheSuccess = false;
                }
            }
        }
        if (!localCacheEntryPath && !cacheEntryBuffer) {
            terminal.writeVerboseLine('This project was not found in the build cache.');
            return false;
        }
        terminal.writeLine('Build cache hit.');
        terminal.writeVerboseLine(`Cache key: ${cacheId}`);
        const projectFolderPath = this._project.projectFolder;
        // Purge output folders
        terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);
        await Promise.all(this._projectOutputFolderNames.map((outputFolderName) => node_core_library_1.FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)));
        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);
        let restoreSuccess = false;
        if (tarUtility && localCacheEntryPath) {
            const logFilePath = this._getTarLogFilePath('untar');
            const tarExitCode = await tarUtility.tryUntarAsync({
                archivePath: localCacheEntryPath,
                outputFolderPath: projectFolderPath,
                logFilePath
            });
            if (tarExitCode === 0) {
                restoreSuccess = true;
                terminal.writeLine('Successfully restored output from the build cache.');
            }
            else {
                terminal.writeWarningLine('Unable to restore output from the build cache. ' +
                    `See "${logFilePath}" for logs from the tar process.`);
            }
        }
        if (updateLocalCacheSuccess === false) {
            terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');
        }
        return restoreSuccess;
    }
    async trySetCacheEntryAsync(terminal, specifiedCacheId) {
        var _a, _b, _c;
        if (!this._cacheWriteEnabled) {
            // Skip writing local and cloud build caches, without any noise
            return true;
        }
        const cacheId = specifiedCacheId || this._cacheId;
        if (!cacheId) {
            terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');
            return false;
        }
        const filesToCache = await this._tryCollectPathsToCacheAsync(terminal);
        if (!filesToCache) {
            return false;
        }
        terminal.writeVerboseLine(`Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`);
        let localCacheEntryPath;
        const tarUtility = await ProjectBuildCache._tryGetTarUtility(terminal);
        if (tarUtility) {
            const finalLocalCacheEntryPath = this._localBuildCacheProvider.getCacheEntryPath(cacheId);
            // Derive the temp file from the destination path to ensure they are on the same volume
            // In the case of a shared network drive containing the build cache, we also need to make
            // sure the the temp path won't be shared by two parallel rush builds.
            const randomSuffix = crypto.randomBytes(8).toString('hex');
            const tempLocalCacheEntryPath = `${finalLocalCacheEntryPath}-${randomSuffix}.temp`;
            const logFilePath = this._getTarLogFilePath('tar');
            const tarExitCode = await tarUtility.tryCreateArchiveFromProjectPathsAsync({
                archivePath: tempLocalCacheEntryPath,
                paths: filesToCache.outputFilePaths,
                project: this._project,
                logFilePath
            });
            if (tarExitCode === 0) {
                // Move after the archive is finished so that if the process is interrupted we aren't left with an invalid file
                try {
                    await node_core_library_1.Async.runWithRetriesAsync({
                        action: () => node_core_library_1.FileSystem.moveAsync({
                            sourcePath: tempLocalCacheEntryPath,
                            destinationPath: finalLocalCacheEntryPath,
                            overwrite: true
                        }),
                        maxRetries: 2,
                        retryDelayMs: 500
                    });
                }
                catch (moveError) {
                    try {
                        await node_core_library_1.FileSystem.deleteFileAsync(tempLocalCacheEntryPath);
                    }
                    catch (deleteError) {
                        // Ignored
                    }
                    throw moveError;
                }
                localCacheEntryPath = finalLocalCacheEntryPath;
            }
            else {
                terminal.writeWarningLine(`"tar" exited with code ${tarExitCode} while attempting to create the cache entry. ` +
                    `See "${logFilePath}" for logs from the tar process.`);
                return false;
            }
        }
        else {
            terminal.writeWarningLine(`Unable to locate "tar". Please ensure that "tar" is on your PATH environment variable, or set the ` +
                `${EnvironmentConfiguration_1.EnvironmentVariableNames.RUSH_TAR_BINARY_PATH} environment variable to the full path to the "tar" binary.`);
            return false;
        }
        let cacheEntryBuffer;
        let setCloudCacheEntryPromise;
        // Note that "writeAllowed" settings (whether in config or environment) always apply to
        // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and
        // write to the local build cache.
        if ((_a = this._cloudBuildCacheProvider) === null || _a === void 0 ? void 0 : _a.isCacheWriteAllowed) {
            if (localCacheEntryPath) {
                cacheEntryBuffer = await node_core_library_1.FileSystem.readFileToBufferAsync(localCacheEntryPath);
            }
            else {
                throw new node_core_library_1.InternalError('Expected the local cache entry path to be set.');
            }
            setCloudCacheEntryPromise = (_b = this._cloudBuildCacheProvider) === null || _b === void 0 ? void 0 : _b.trySetCacheEntryBufferAsync(terminal, cacheId, cacheEntryBuffer);
        }
        const updateCloudCacheSuccess = (_c = (await setCloudCacheEntryPromise)) !== null && _c !== void 0 ? _c : true;
        const success = updateCloudCacheSuccess && !!localCacheEntryPath;
        if (success) {
            terminal.writeLine('Successfully set cache entry.');
            terminal.writeVerboseLine(`Cache key: ${cacheId}`);
        }
        else if (!localCacheEntryPath && updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set local cache entry.');
        }
        else if (localCacheEntryPath && !updateCloudCacheSuccess) {
            terminal.writeWarningLine('Unable to set cloud cache entry.');
        }
        else {
            terminal.writeWarningLine('Unable to set both cloud and local cache entries.');
        }
        return success;
    }
    /**
     * Walks the declared output folders of the project and collects a list of files.
     * @returns The list of output files as project-relative paths, or `undefined` if a
     *   symbolic link was encountered.
     */
    async _tryCollectPathsToCacheAsync(terminal) {
        const projectFolderPath = this._project.projectFolder;
        const outputFilePaths = [];
        const queue = [];
        const filteredOutputFolderNames = [];
        let hasSymbolicLinks = false;
        // Adds child directories to the queue, files to the path list, and bails on symlinks
        function processChildren(relativePath, diskPath, children) {
            for (const child of children) {
                const childRelativePath = `${relativePath}/${child.name}`;
                if (child.isSymbolicLink()) {
                    terminal.writeError(`Unable to include "${childRelativePath}" in build cache. It is a symbolic link.`);
                    hasSymbolicLinks = true;
                }
                else if (child.isDirectory()) {
                    queue.push([childRelativePath, `${diskPath}/${child.name}`]);
                }
                else {
                    outputFilePaths.push(childRelativePath);
                }
            }
        }
        // Handle declared output folders.
        for (const outputFolder of this._projectOutputFolderNames) {
            const diskPath = `${projectFolderPath}/${outputFolder}`;
            try {
                const children = await node_core_library_1.FileSystem.readFolderItemsAsync(diskPath);
                processChildren(outputFolder, diskPath, children);
                // The folder exists, record it
                filteredOutputFolderNames.push(outputFolder);
            }
            catch (error) {
                if (!node_core_library_1.FileSystem.isNotExistError(error)) {
                    throw error;
                }
                // If the folder does not exist, ignore it.
            }
        }
        for (const [relativePath, diskPath] of queue) {
            const children = await node_core_library_1.FileSystem.readFolderItemsAsync(diskPath);
            processChildren(relativePath, diskPath, children);
        }
        if (hasSymbolicLinks) {
            // Symbolic links do not round-trip safely.
            return undefined;
        }
        // Add additional output file paths
        await node_core_library_1.Async.forEachAsync(this._additionalProjectOutputFilePaths, async (additionalProjectOutputFilePath) => {
            const fullPath = `${projectFolderPath}/${additionalProjectOutputFilePath}`;
            const pathExists = await node_core_library_1.FileSystem.existsAsync(fullPath);
            if (pathExists) {
                outputFilePaths.push(additionalProjectOutputFilePath);
            }
        }, { concurrency: 10 });
        // Ensure stable output path order.
        outputFilePaths.sort();
        return {
            outputFilePaths,
            filteredOutputFolderNames
        };
    }
    _getTarLogFilePath(mode) {
        return path.join(this._project.projectRushTempFolder, `${this._cacheId}.${mode}.log`);
    }
    static async _getCacheIdAsync({ projectChangeAnalyzer, project, terminal, projectOutputFolderNames, configHash, additionalContext, phaseName, buildCacheConfiguration: { getCacheEntryId } }) {
        // The project state hash is calculated in the following method:
        // - The current project's hash (see ProjectChangeAnalyzer.getProjectStateHash) is
        //   calculated and appended to an array
        // - The current project's recursive dependency projects' hashes are calculated
        //   and appended to the array
        // - A SHA1 hash is created and the following data is fed into it, in order:
        //   1. The JSON-serialized list of output folder names for this
        //      project (see ProjectBuildCache._projectOutputFolderNames)
        //   2. The configHash from the operation's runner
        //   3. Each dependency project hash (from the array constructed in previous steps),
        //      in sorted alphanumerical-sorted order
        // - A hex digest of the hash is returned
        const projectStates = [];
        const projectsToProcess = new Set();
        projectsToProcess.add(project);
        for (const projectToProcess of projectsToProcess) {
            const projectState = await projectChangeAnalyzer._tryGetProjectStateHashAsync(projectToProcess, terminal);
            if (!projectState) {
                // If we hit any projects with unknown state, return unknown cache ID
                return undefined;
            }
            else {
                projectStates.push(projectState);
                for (const dependency of projectToProcess.dependencyProjects) {
                    projectsToProcess.add(dependency);
                }
            }
        }
        const sortedProjectStates = projectStates.sort();
        const hash = crypto.createHash('sha1');
        // This value is used to force cache bust when the build cache algorithm changes
        hash.update(`${RushConstants_1.RushConstants.buildCacheVersion}`);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        const serializedOutputFolders = JSON.stringify(projectOutputFolderNames);
        hash.update(serializedOutputFolders);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        hash.update(configHash);
        hash.update(RushConstants_1.RushConstants.hashDelimiter);
        if (additionalContext) {
            for (const key of Object.keys(additionalContext).sort()) {
                // Add additional context keys and values.
                //
                // This choice (to modify the hash for every key regardless of whether a value is set) implies
                // that just _adding_ an env var to the list of dependsOnEnvVars will modify its hash. This
                // seems appropriate, because this behavior is consistent whether or not the env var happens
                // to have a value.
                hash.update(`${key}=${additionalContext[key]}`);
                hash.update(RushConstants_1.RushConstants.hashDelimiter);
            }
        }
        for (const projectHash of sortedProjectStates) {
            hash.update(projectHash);
            hash.update(RushConstants_1.RushConstants.hashDelimiter);
        }
        const projectStateHash = hash.digest('hex');
        return getCacheEntryId({
            projectName: project.packageName,
            projectStateHash,
            phaseName
        });
    }
}
exports.ProjectBuildCache = ProjectBuildCache;
/**
 * null === we haven't tried to initialize yet
 * undefined === unable to initialize
 */
ProjectBuildCache._tarUtilityPromise = null;
//# sourceMappingURL=ProjectBuildCache.js.map