{"version":3,"file":"getHashesForGlobsAsync.js","sourceRoot":"","sources":["../../../src/logic/buildCache/getHashesForGlobsAsync.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { getGitHashForFiles } from '@rushstack/package-deps-hash';\nimport * as path from 'path';\nimport type { IRawRepoState } from '../ProjectChangeAnalyzer';\n\nasync function expandGlobPatternsAsync(\n  globPatterns: Iterable<string>,\n  packagePath: string\n): Promise<string[]> {\n  const { default: glob } = await import('fast-glob');\n  const matches: string[] = await glob(Array.from(globPatterns), {\n    cwd: packagePath,\n    onlyFiles: true,\n    // We want to keep path's type unchanged,\n    // i.e. if the pattern was a  relative path, then matched paths should also be relative paths\n    //      if the pattern was an absolute path, then matched paths should also be absolute paths\n    //\n    // We are doing this because these paths are going to be used to calculate a hash for the build cache and some users\n    // might choose to depend on global files (e.g. `/etc/os-release`) and some might choose to depend on local files\n    // (e.g. `../path/to/workspace/file`)\n    //\n    // In both cases we want that path to the resource would be the same on all machines,\n    // regardless of what is the current working directory.\n    //\n    // That being said, we want to keep `absolute` option here as false:\n    absolute: false\n  });\n\n  if (matches.length === 0) {\n    throw new Error(\n      `Couldn't find any files matching provided glob patterns: [\"${Array.from(globPatterns).join('\", \"')}\"].`\n    );\n  }\n\n  return matches;\n}\n\ninterface IKnownHashesResult {\n  foundPaths: Map<string, string>;\n  missingPaths: string[];\n}\n\nfunction getKnownHashes(\n  filePaths: string[],\n  packagePath: string,\n  repoState: IRawRepoState\n): IKnownHashesResult {\n  const missingPaths: string[] = [];\n  const foundPaths: Map<string, string> = new Map();\n\n  for (const filePath of filePaths) {\n    const absolutePath: string = path.isAbsolute(filePath) ? filePath : path.join(packagePath, filePath);\n\n    /**\n     * We are using RegExp here to prevent false positives in the following string.replace function\n     * - `^` anchor makes sure that we are replacing only the beginning of the string\n     * - extra `/` makes sure that we are remove extra slash from the relative path\n     */\n    const gitFilePath: string = absolutePath.replace(new RegExp('^' + repoState.rootDir + '/'), '');\n    const foundHash: string | undefined = repoState.rawHashes.get(gitFilePath);\n\n    if (foundHash) {\n      foundPaths.set(filePath, foundHash);\n    } else {\n      missingPaths.push(filePath);\n    }\n  }\n\n  return { foundPaths, missingPaths };\n}\n\nexport async function getHashesForGlobsAsync(\n  globPatterns: Iterable<string>,\n  packagePath: string,\n  repoState: IRawRepoState | undefined\n): Promise<Map<string, string>> {\n  const filePaths: string[] = await expandGlobPatternsAsync(globPatterns, packagePath);\n\n  if (!repoState) {\n    return getGitHashForFiles(filePaths, packagePath);\n  }\n\n  const { foundPaths, missingPaths } = getKnownHashes(filePaths, packagePath, repoState);\n  const calculatedHashes: Map<string, string> = getGitHashForFiles(missingPaths, packagePath);\n\n  /**\n   * We want to keep the order of the output the same regardless whether the file was already\n   * hashed by git or not (as this can change, e.g. due to .gitignore).\n   * Therefore we will populate our final hashes map in the same order as `filePaths`.\n   */\n  const result: Map<string, string> = new Map();\n  for (const filePath of filePaths) {\n    const hash: string | undefined = foundPaths.get(filePath) || calculatedHashes.get(filePath);\n    if (!hash) {\n      // Sanity check -- this should never happen\n      throw new Error(`Failed to calculate hash of file: \"${filePath}\"`);\n    }\n    result.set(filePath, hash);\n  }\n\n  return result;\n}\n"]}