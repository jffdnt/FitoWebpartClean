"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDisplayName = exports.formatCommand = exports.getCustomParameterValuesByPhase = exports.getScriptToRun = exports.initializeShellOperationRunner = exports.ShellOperationRunnerPlugin = exports.PLUGIN_NAME = void 0;
const RushConstants_1 = require("../RushConstants");
const NullOperationRunner_1 = require("./NullOperationRunner");
const ShellOperationRunner_1 = require("./ShellOperationRunner");
const OperationStatus_1 = require("./OperationStatus");
exports.PLUGIN_NAME = 'ShellOperationRunnerPlugin';
/**
 * Core phased command plugin that provides the functionality for executing an operation via shell command.
 */
class ShellOperationRunnerPlugin {
    apply(hooks) {
        hooks.createOperations.tap(exports.PLUGIN_NAME, createShellOperations);
    }
}
exports.ShellOperationRunnerPlugin = ShellOperationRunnerPlugin;
function createShellOperations(operations, context) {
    const { rushConfiguration } = context;
    const getCustomParameterValuesForPhase = getCustomParameterValuesByPhase();
    for (const operation of operations) {
        const { associatedPhase: phase, associatedProject: project } = operation;
        if (phase && project && !operation.runner) {
            // This is a shell command. In the future, may consider having a property on the initial operation
            // to specify a runner type requested in rush-project.json
            const customParameterValues = getCustomParameterValuesForPhase(phase);
            const displayName = getDisplayName(phase, project);
            const rawCommandToRun = getScriptToRun(project, phase.name, phase.shellCommand);
            const commandToRun = rawCommandToRun !== undefined ? formatCommand(rawCommandToRun, customParameterValues) : undefined;
            operation.runner = initializeShellOperationRunner({
                phase,
                project,
                displayName,
                commandToRun,
                rushConfiguration
            });
        }
    }
    return operations;
}
function initializeShellOperationRunner(options) {
    const { phase, project, rushConfiguration, commandToRun, displayName } = options;
    if (commandToRun === undefined && phase.missingScriptBehavior === 'error') {
        throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);
    }
    if (commandToRun) {
        return new ShellOperationRunner_1.ShellOperationRunner({
            commandToRun: commandToRun || '',
            displayName,
            phase,
            rushConfiguration,
            rushProject: project
        });
    }
    else {
        // Empty build script indicates a no-op, so use a no-op runner
        return new NullOperationRunner_1.NullOperationRunner({
            name: displayName,
            result: OperationStatus_1.OperationStatus.NoOp,
            silent: phase.missingScriptBehavior === 'silent'
        });
    }
}
exports.initializeShellOperationRunner = initializeShellOperationRunner;
function getScriptToRun(rushProject, commandToRun, shellCommand) {
    const { scripts } = rushProject.packageJson;
    const rawCommand = shellCommand !== null && shellCommand !== void 0 ? shellCommand : scripts === null || scripts === void 0 ? void 0 : scripts[commandToRun];
    if (rawCommand === undefined || rawCommand === null) {
        return undefined;
    }
    return rawCommand;
}
exports.getScriptToRun = getScriptToRun;
/**
 * Memoizer for custom parameter values by phase
 * @returns A function that returns the custom parameter values for a given phase
 */
function getCustomParameterValuesByPhase() {
    const customParametersByPhase = new Map();
    function getCustomParameterValuesForPhase(phase) {
        let customParameterValues = customParametersByPhase.get(phase);
        if (!customParameterValues) {
            customParameterValues = [];
            for (const tsCommandLineParameter of phase.associatedParameters) {
                tsCommandLineParameter.appendToArgList(customParameterValues);
            }
            customParametersByPhase.set(phase, customParameterValues);
        }
        return customParameterValues;
    }
    return getCustomParameterValuesForPhase;
}
exports.getCustomParameterValuesByPhase = getCustomParameterValuesByPhase;
function formatCommand(rawCommand, customParameterValues) {
    if (!rawCommand) {
        return '';
    }
    else {
        const fullCommand = `${rawCommand} ${customParameterValues.join(' ')}`;
        return process.platform === 'win32' ? (0, ShellOperationRunner_1.convertSlashesForWindows)(fullCommand) : fullCommand;
    }
}
exports.formatCommand = formatCommand;
function getDisplayName(phase, project) {
    if (phase.isSynthetic) {
        // Because this is a synthetic phase, just use the project name because there aren't any other phases
        return project.packageName;
    }
    else {
        const phaseNameWithoutPrefix = phase.name.slice(RushConstants_1.RushConstants.phaseNamePrefix.length);
        return `${project.packageName} (${phaseNameWithoutPrefix})`;
    }
}
exports.getDisplayName = getDisplayName;
//# sourceMappingURL=ShellOperationRunnerPlugin.js.map