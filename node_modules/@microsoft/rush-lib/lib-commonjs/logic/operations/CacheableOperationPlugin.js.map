{"version":3,"file":"CacheableOperationPlugin.js","sourceRoot":"","sources":["../../../src/logic/operations/CacheableOperationPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as crypto from 'crypto';\nimport { Async, InternalError, NewlineKind, Sort } from '@rushstack/node-core-library';\nimport { CollatedTerminal, type CollatedWriter } from '@rushstack/stream-collator';\nimport { DiscardStdoutTransform, TextRewriterTransform } from '@rushstack/terminal';\nimport { SplitterTransform, type TerminalWritable, type ITerminal, Terminal } from '@rushstack/terminal';\n\nimport { CollatedTerminalProvider } from '../../utilities/CollatedTerminalProvider';\nimport { OperationStatus } from './OperationStatus';\nimport { CobuildLock, type ICobuildCompletedState } from '../cobuild/CobuildLock';\nimport { ProjectBuildCache } from '../buildCache/ProjectBuildCache';\nimport { RushConstants } from '../RushConstants';\nimport { type IOperationSettings, RushProjectConfiguration } from '../../api/RushProjectConfiguration';\nimport { getHashesForGlobsAsync } from '../buildCache/getHashesForGlobsAsync';\nimport {\n  initializeProjectLogFilesAsync,\n  getProjectLogFilePaths,\n  type ILogFilePaths\n} from './ProjectLogWritable';\nimport type { CobuildConfiguration } from '../../api/CobuildConfiguration';\nimport { DisjointSet } from '../cobuild/DisjointSet';\nimport { PeriodicCallback } from './PeriodicCallback';\nimport { NullTerminalProvider } from '../../utilities/NullTerminalProvider';\n\nimport type { Operation } from './Operation';\nimport type { IOperationRunnerContext } from './IOperationRunner';\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type {\n  IExecuteOperationsContext,\n  IPhasedCommandPlugin,\n  PhasedCommandHooks\n} from '../../pluginFramework/PhasedCommandHooks';\nimport type { IPhase } from '../../api/CommandLineConfiguration';\nimport type { IRawRepoState, ProjectChangeAnalyzer } from '../ProjectChangeAnalyzer';\nimport type { OperationMetadataManager } from './OperationMetadataManager';\nimport type { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport type { IOperationExecutionResult } from './IOperationExecutionResult';\nimport type { OperationExecutionRecord } from './OperationExecutionRecord';\n\nconst PLUGIN_NAME: 'CacheablePhasedOperationPlugin' = 'CacheablePhasedOperationPlugin';\nconst PERIODIC_CALLBACK_INTERVAL_IN_SECONDS: number = 10;\n\nexport interface IProjectDeps {\n  files: { [filePath: string]: string };\n  arguments: string;\n}\n\nexport interface IOperationBuildCacheContext {\n  isCacheWriteAllowed: boolean;\n  isCacheReadAllowed: boolean;\n\n  projectChangeAnalyzer: ProjectChangeAnalyzer;\n  projectBuildCache: ProjectBuildCache | undefined;\n  cacheDisabledReason: string | undefined;\n  operationSettings: IOperationSettings | undefined;\n\n  cobuildLock: CobuildLock | undefined;\n\n  // The id of the cluster contains the operation, used when acquiring cobuild lock\n  cobuildClusterId: string | undefined;\n\n  // Controls the log for the cache subsystem\n  buildCacheTerminal: ITerminal | undefined;\n  buildCacheTerminalWritable: TerminalWritable | undefined;\n\n  periodicCallback: PeriodicCallback;\n  cacheRestored: boolean;\n  isCacheReadAttempted: boolean;\n}\n\nexport interface ICacheableOperationPluginOptions {\n  allowWarningsInSuccessfulBuild: boolean;\n  buildCacheConfiguration: BuildCacheConfiguration;\n  cobuildConfiguration: CobuildConfiguration | undefined;\n  terminal: ITerminal;\n}\n\nexport class CacheableOperationPlugin implements IPhasedCommandPlugin {\n  private _buildCacheContextByOperation: Map<Operation, IOperationBuildCacheContext> = new Map();\n\n  private readonly _options: ICacheableOperationPluginOptions;\n\n  public constructor(options: ICacheableOperationPluginOptions) {\n    this._options = options;\n  }\n\n  public apply(hooks: PhasedCommandHooks): void {\n    const { allowWarningsInSuccessfulBuild, buildCacheConfiguration, cobuildConfiguration, terminal } =\n      this._options;\n\n    hooks.beforeExecuteOperations.tapPromise(\n      PLUGIN_NAME,\n      async (\n        recordByOperation: Map<Operation, IOperationExecutionResult>,\n        context: IExecuteOperationsContext\n      ): Promise<void> => {\n        const { isIncrementalBuildAllowed, projectChangeAnalyzer, projectConfigurations, isInitial } =\n          context;\n\n        const disjointSet: DisjointSet<Operation> | undefined = cobuildConfiguration?.cobuildFeatureEnabled\n          ? new DisjointSet()\n          : undefined;\n\n        for (const operation of recordByOperation.keys()) {\n          if (\n            operation.settings?.allowCobuildWithoutCache &&\n            !cobuildConfiguration?.cobuildWithoutCacheAllowed\n          ) {\n            throw new Error(\n              `Operation ${operation.name} is not allowed to run without the cobuild orchestration experiment enabled. You must enable the \"allowCobuildWithoutCache\" experiment in experiments.json.`\n            );\n          }\n          if (\n            operation.settings?.allowCobuildWithoutCache &&\n            !operation.settings.disableBuildCacheForOperation\n          ) {\n            throw new Error(\n              `Operation ${operation.name} must have disableBuildCacheForOperation set to true when using the cobuild orchestration experiment. This is to prevent implicit cache dependencies for this operation.`\n            );\n          }\n        }\n\n        await Async.forEachAsync(\n          recordByOperation.keys(),\n          async (operation: Operation) => {\n            const { associatedProject, associatedPhase, runner, settings: operationSettings } = operation;\n            if (!associatedProject || !associatedPhase || !runner) {\n              return;\n            }\n\n            const { name: phaseName } = associatedPhase;\n\n            const projectConfiguration: RushProjectConfiguration | undefined =\n              projectConfigurations.get(associatedProject);\n\n            // This value can *currently* be cached per-project, but in the future the list of files will vary\n            // depending on the selected phase.\n            const fileHashes: Map<string, string> | undefined =\n              await projectChangeAnalyzer._tryGetProjectDependenciesAsync(associatedProject, terminal);\n\n            if (!fileHashes) {\n              throw new Error(\n                `Build cache is only supported if running in a Git repository. Either disable the build cache or run Rush in a Git repository.`\n              );\n            }\n\n            const cacheDisabledReason: string | undefined =\n              RushProjectConfiguration.getCacheDisabledReasonForProject({\n                projectConfiguration,\n                phaseName: phaseName,\n                isNoOp: operation.isNoOp,\n                trackedFileNames: fileHashes.keys()\n              });\n\n            disjointSet?.add(operation);\n\n            const buildCacheContext: IOperationBuildCacheContext = {\n              // Supports cache writes by default for initial operations.\n              // Don't write during watch runs for performance reasons (and to avoid flooding the cache)\n              isCacheWriteAllowed: isInitial,\n              isCacheReadAllowed: isIncrementalBuildAllowed,\n              projectBuildCache: undefined,\n              projectChangeAnalyzer,\n              operationSettings,\n              cacheDisabledReason,\n              cobuildLock: undefined,\n              cobuildClusterId: undefined,\n              buildCacheTerminal: undefined,\n              buildCacheTerminalWritable: undefined,\n              periodicCallback: new PeriodicCallback({\n                interval: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 1000\n              }),\n              cacheRestored: false,\n              isCacheReadAttempted: false\n            };\n            // Upstream runners may mutate the property of build cache context for downstream runners\n            this._buildCacheContextByOperation.set(operation, buildCacheContext);\n          },\n          {\n            concurrency: 10\n          }\n        );\n\n        if (disjointSet) {\n          clusterOperations(disjointSet, this._buildCacheContextByOperation);\n          for (const operationSet of disjointSet.getAllSets()) {\n            if (cobuildConfiguration?.cobuildFeatureEnabled && cobuildConfiguration.cobuildContextId) {\n              // Get a deterministic ordered array of operations, which is important to get a deterministic cluster id.\n              const groupedOperations: Operation[] = Array.from(operationSet);\n              Sort.sortBy(groupedOperations, (operation: Operation) => {\n                return operation.name;\n              });\n\n              // Generates cluster id, cluster id comes from the project folder and operation name of all operations in the same cluster.\n              const hash: crypto.Hash = crypto.createHash('sha1');\n              for (const operation of groupedOperations) {\n                const { associatedPhase: phase, associatedProject: project } = operation;\n                if (project && phase) {\n                  hash.update(project.projectRelativeFolder);\n                  hash.update(RushConstants.hashDelimiter);\n                  hash.update(operation.name ?? phase.name);\n                  hash.update(RushConstants.hashDelimiter);\n                }\n              }\n              const cobuildClusterId: string = hash.digest('hex');\n\n              // Assign same cluster id to all operations in the same cluster.\n              for (const record of groupedOperations) {\n                const buildCacheContext: IOperationBuildCacheContext =\n                  this._getBuildCacheContextByOperationOrThrow(record);\n                buildCacheContext.cobuildClusterId = cobuildClusterId;\n              }\n            }\n          }\n        }\n      }\n    );\n\n    hooks.beforeExecuteOperation.tapPromise(\n      PLUGIN_NAME,\n      async (\n        runnerContext: IOperationRunnerContext & IOperationExecutionResult\n      ): Promise<OperationStatus | undefined> => {\n        if (this._buildCacheContextByOperation.size === 0) {\n          return;\n        }\n\n        const buildCacheContext: IOperationBuildCacheContext | undefined =\n          this._getBuildCacheContextByOperation(runnerContext.operation);\n\n        if (!buildCacheContext) {\n          return;\n        }\n\n        const record: OperationExecutionRecord = runnerContext as OperationExecutionRecord;\n\n        const {\n          associatedProject: project,\n          associatedPhase: phase,\n          runner,\n          _operationMetadataManager: operationMetadataManager\n        } = record;\n\n        if (\n          !project ||\n          !phase ||\n          !runner?.cacheable ||\n          // this check is just to make the types happy, it will always be defined if project + phase are defined.\n          !operationMetadataManager\n        ) {\n          return;\n        }\n\n        const runBeforeExecute = async (): Promise<OperationStatus | undefined> => {\n          if (\n            !buildCacheContext.buildCacheTerminal ||\n            buildCacheContext.buildCacheTerminalWritable?.isOpen === false\n          ) {\n            // The writable does not exist or has been closed, re-create one\n            // eslint-disable-next-line require-atomic-updates\n            buildCacheContext.buildCacheTerminal = await this._createBuildCacheTerminalAsync({\n              record,\n              buildCacheContext,\n              buildCacheEnabled: buildCacheConfiguration?.buildCacheEnabled,\n              rushProject: project,\n              logFilenameIdentifier: operationMetadataManager.logFilenameIdentifier,\n              quietMode: record.quietMode,\n              debugMode: record.debugMode\n            });\n          }\n\n          const buildCacheTerminal: ITerminal = buildCacheContext.buildCacheTerminal;\n          const configHash: string = runner.getConfigHash() || '';\n\n          let projectBuildCache: ProjectBuildCache | undefined = await this._tryGetProjectBuildCacheAsync({\n            buildCacheContext,\n            buildCacheConfiguration,\n            rushProject: project,\n            phase,\n            configHash,\n            terminal: buildCacheTerminal,\n            operationMetadataManager,\n            operation: record.operation\n          });\n\n          // Try to acquire the cobuild lock\n          let cobuildLock: CobuildLock | undefined;\n          if (cobuildConfiguration?.cobuildFeatureEnabled) {\n            if (\n              cobuildConfiguration?.cobuildLeafProjectLogOnlyAllowed &&\n              record.operation.consumers.size === 0 &&\n              !projectBuildCache\n            ) {\n              // When the leaf project log only is allowed and the leaf project is build cache \"disabled\", try to get\n              // a log files only project build cache\n              projectBuildCache = await this._tryGetLogOnlyProjectBuildCacheAsync({\n                buildCacheConfiguration,\n                cobuildConfiguration,\n                buildCacheContext,\n                rushProject: project,\n                phase,\n                configHash,\n                terminal: buildCacheTerminal,\n                operationMetadataManager\n              });\n              if (projectBuildCache) {\n                buildCacheTerminal.writeVerboseLine(\n                  `Log files only build cache is enabled for the project \"${project.packageName}\" because the cobuild leaf project log only is allowed`\n                );\n              } else {\n                buildCacheTerminal.writeWarningLine(\n                  `Failed to get log files only build cache for the project \"${project.packageName}\"`\n                );\n              }\n            }\n\n            cobuildLock = await this._tryGetCobuildLockAsync({\n              buildCacheContext,\n              projectBuildCache,\n              cobuildConfiguration,\n              packageName: project.packageName,\n              phaseName: phase.name\n            });\n          }\n\n          // eslint-disable-next-line require-atomic-updates -- we are mutating the build cache context intentionally\n          buildCacheContext.cobuildLock = cobuildLock;\n\n          // If possible, we want to skip this operation -- either by restoring it from the\n          // cache, if caching is enabled, or determining that the project\n          // is unchanged (using the older incremental execution logic). These two approaches,\n          // \"caching\" and \"skipping\", are incompatible, so only one applies.\n          //\n          // Note that \"caching\" and \"skipping\" take two different approaches\n          // to tracking dependents:\n          //\n          //   - For caching, \"isCacheReadAllowed\" is set if a project supports\n          //     incremental builds, and determining whether this project or a dependent\n          //     has changed happens inside the hashing logic.\n          //\n\n          const { error: errorLogPath } = getProjectLogFilePaths({\n            project,\n            logFilenameIdentifier: operationMetadataManager.logFilenameIdentifier\n          });\n          const restoreCacheAsync = async (\n            // TODO: Investigate if `projectBuildCacheForRestore` is always the same instance as `projectBuildCache`\n            // above, and if it is, remove this parameter\n            projectBuildCacheForRestore: ProjectBuildCache | undefined,\n            specifiedCacheId?: string\n          ): Promise<boolean> => {\n            buildCacheContext.isCacheReadAttempted = true;\n            const restoreFromCacheSuccess: boolean | undefined =\n              await projectBuildCacheForRestore?.tryRestoreFromCacheAsync(\n                buildCacheTerminal,\n                specifiedCacheId\n              );\n            if (restoreFromCacheSuccess) {\n              buildCacheContext.cacheRestored = true;\n              await runnerContext.runWithTerminalAsync(\n                async (taskTerminal, terminalProvider) => {\n                  // Restore the original state of the operation without cache\n                  await operationMetadataManager?.tryRestoreAsync({\n                    terminalProvider,\n                    terminal: buildCacheTerminal,\n                    errorLogPath\n                  });\n                },\n                { createLogFile: false }\n              );\n            }\n            return !!restoreFromCacheSuccess;\n          };\n          if (cobuildLock) {\n            // handling rebuilds. \"rush rebuild\" or \"rush retest\" command will save operations to\n            // the build cache once completed, but does not retrieve them (since the \"incremental\"\n            // flag is disabled). However, we still need a cobuild to be able to retrieve a finished\n            // build from another cobuild in this case.\n            const cobuildCompletedState: ICobuildCompletedState | undefined =\n              await cobuildLock.getCompletedStateAsync();\n            if (cobuildCompletedState) {\n              const { status, cacheId } = cobuildCompletedState;\n\n              if (record.operation.settings?.allowCobuildWithoutCache) {\n                // This should only be enabled if the experiment for cobuild orchestration is enabled.\n                return status;\n              }\n\n              const restoreFromCacheSuccess: boolean = await restoreCacheAsync(\n                cobuildLock.projectBuildCache,\n                cacheId\n              );\n\n              if (restoreFromCacheSuccess) {\n                return status;\n              }\n            } else if (!buildCacheContext.isCacheReadAttempted && buildCacheContext.isCacheReadAllowed) {\n              const restoreFromCacheSuccess: boolean = await restoreCacheAsync(projectBuildCache);\n\n              if (restoreFromCacheSuccess) {\n                return OperationStatus.FromCache;\n              }\n            }\n          } else if (buildCacheContext.isCacheReadAllowed) {\n            const restoreFromCacheSuccess: boolean = await restoreCacheAsync(projectBuildCache);\n\n            if (restoreFromCacheSuccess) {\n              return OperationStatus.FromCache;\n            }\n          }\n\n          if (buildCacheContext.isCacheWriteAllowed && cobuildLock) {\n            const acquireSuccess: boolean = await cobuildLock.tryAcquireLockAsync();\n            if (acquireSuccess) {\n              const { periodicCallback } = buildCacheContext;\n              periodicCallback.addCallback(async () => {\n                await cobuildLock?.renewLockAsync();\n              });\n              periodicCallback.start();\n            } else {\n              setTimeout(() => {\n                record.status = OperationStatus.Ready;\n              }, 500);\n              return OperationStatus.Executing;\n            }\n          }\n        };\n\n        return await runBeforeExecute();\n      }\n    );\n\n    hooks.afterExecuteOperation.tapPromise(\n      PLUGIN_NAME,\n      async (runnerContext: IOperationRunnerContext): Promise<void> => {\n        const record: OperationExecutionRecord = runnerContext as OperationExecutionRecord;\n        const { status, stopwatch, _operationMetadataManager: operationMetadataManager, operation } = record;\n\n        const { associatedProject: project, associatedPhase: phase, runner } = operation;\n\n        if (!project || !phase || !runner?.cacheable || !operationMetadataManager) {\n          return;\n        }\n\n        const buildCacheContext: IOperationBuildCacheContext | undefined =\n          this._getBuildCacheContextByOperation(operation);\n\n        if (!buildCacheContext) {\n          return;\n        }\n\n        // No need to run for the following operation status\n        if (!record.isTerminal || record.status === OperationStatus.NoOp) {\n          return;\n        }\n\n        const { cobuildLock, projectBuildCache, isCacheWriteAllowed, buildCacheTerminal, cacheRestored } =\n          buildCacheContext;\n\n        try {\n          if (!cacheRestored) {\n            // Save the metadata to disk\n            const { logFilenameIdentifier } = operationMetadataManager;\n            const { duration: durationInSeconds } = stopwatch;\n            const {\n              text: logPath,\n              error: errorLogPath,\n              jsonl: logChunksPath\n            } = getProjectLogFilePaths({\n              project,\n              logFilenameIdentifier\n            });\n            await operationMetadataManager.saveAsync({\n              durationInSeconds,\n              cobuildContextId: cobuildLock?.cobuildConfiguration.cobuildContextId,\n              cobuildRunnerId: cobuildLock?.cobuildConfiguration.cobuildRunnerId,\n              logPath,\n              errorLogPath,\n              logChunksPath\n            });\n          }\n\n          if (!buildCacheTerminal) {\n            // This should not happen\n            throw new InternalError(`Build Cache Terminal is not created`);\n          }\n\n          let setCompletedStatePromiseFunction: (() => Promise<void> | undefined) | undefined;\n          let setCacheEntryPromise: (() => Promise<boolean> | undefined) | undefined;\n          if (cobuildLock && isCacheWriteAllowed) {\n            const { cacheId, contextId } = cobuildLock.cobuildContext;\n\n            let finalCacheId: string = cacheId;\n            if (status === OperationStatus.Failure) {\n              finalCacheId = `${cacheId}-${contextId}-failed`;\n            } else if (status === OperationStatus.SuccessWithWarning && !record.runner.warningsAreAllowed) {\n              finalCacheId = `${cacheId}-${contextId}-warnings`;\n            }\n            switch (status) {\n              case OperationStatus.SuccessWithWarning:\n              case OperationStatus.Success:\n              case OperationStatus.Failure: {\n                const currentStatus: ICobuildCompletedState['status'] = status;\n                setCompletedStatePromiseFunction = () => {\n                  return cobuildLock?.setCompletedStateAsync({\n                    status: currentStatus,\n                    cacheId: finalCacheId\n                  });\n                };\n                setCacheEntryPromise = () =>\n                  cobuildLock.projectBuildCache.trySetCacheEntryAsync(buildCacheTerminal, finalCacheId);\n              }\n            }\n          }\n\n          const taskIsSuccessful: boolean =\n            status === OperationStatus.Success ||\n            (status === OperationStatus.SuccessWithWarning &&\n              record.runner.warningsAreAllowed &&\n              allowWarningsInSuccessfulBuild);\n\n          // If the command is successful, we can calculate project hash, and no dependencies were skipped,\n          // write a new cache entry.\n          if (!setCacheEntryPromise && taskIsSuccessful && isCacheWriteAllowed && projectBuildCache) {\n            setCacheEntryPromise = () => projectBuildCache.trySetCacheEntryAsync(buildCacheTerminal);\n          }\n          if (!cacheRestored) {\n            const cacheWriteSuccess: boolean | undefined = await setCacheEntryPromise?.();\n            await setCompletedStatePromiseFunction?.();\n\n            if (cacheWriteSuccess === false && status === OperationStatus.Success) {\n              record.status = OperationStatus.SuccessWithWarning;\n            }\n          }\n        } finally {\n          buildCacheContext.buildCacheTerminalWritable?.close();\n          buildCacheContext.periodicCallback.stop();\n        }\n      }\n    );\n\n    hooks.afterExecuteOperation.tap(\n      PLUGIN_NAME,\n      (record: IOperationRunnerContext & IOperationExecutionResult): void => {\n        const { operation } = record;\n        const buildCacheContext: IOperationBuildCacheContext | undefined =\n          this._buildCacheContextByOperation.get(operation);\n        // Status changes to direct dependents\n        let blockCacheWrite: boolean = !buildCacheContext?.isCacheWriteAllowed;\n\n        switch (record.status) {\n          case OperationStatus.Skipped: {\n            // Skipping means cannot guarantee integrity, so prevent cache writes in dependents.\n            blockCacheWrite = true;\n            break;\n          }\n        }\n\n        // Apply status changes to direct dependents\n        if (blockCacheWrite) {\n          for (const consumer of operation.consumers) {\n            const consumerBuildCacheContext: IOperationBuildCacheContext | undefined =\n              this._getBuildCacheContextByOperation(consumer);\n            if (consumerBuildCacheContext) {\n              consumerBuildCacheContext.isCacheWriteAllowed = false;\n            }\n          }\n        }\n      }\n    );\n\n    hooks.afterExecuteOperations.tapPromise(PLUGIN_NAME, async () => {\n      this._buildCacheContextByOperation.clear();\n    });\n  }\n\n  private _getBuildCacheContextByOperation(operation: Operation): IOperationBuildCacheContext | undefined {\n    const buildCacheContext: IOperationBuildCacheContext | undefined =\n      this._buildCacheContextByOperation.get(operation);\n    return buildCacheContext;\n  }\n\n  private _getBuildCacheContextByOperationOrThrow(operation: Operation): IOperationBuildCacheContext {\n    const buildCacheContext: IOperationBuildCacheContext | undefined =\n      this._getBuildCacheContextByOperation(operation);\n    if (!buildCacheContext) {\n      // This should not happen\n      throw new InternalError(`Build cache context for operation ${operation.name} should be defined`);\n    }\n    return buildCacheContext;\n  }\n\n  private async _tryGetProjectBuildCacheAsync({\n    buildCacheConfiguration,\n    buildCacheContext,\n    rushProject,\n    phase,\n    configHash,\n    terminal,\n    operationMetadataManager,\n    operation\n  }: {\n    buildCacheContext: IOperationBuildCacheContext;\n    buildCacheConfiguration: BuildCacheConfiguration | undefined;\n    rushProject: RushConfigurationProject;\n    phase: IPhase;\n    configHash: string;\n    terminal: ITerminal;\n    operationMetadataManager: OperationMetadataManager | undefined;\n    operation: Operation;\n  }): Promise<ProjectBuildCache | undefined> {\n    if (!buildCacheContext.projectBuildCache) {\n      const { cacheDisabledReason } = buildCacheContext;\n      if (cacheDisabledReason && !operation.settings?.allowCobuildWithoutCache) {\n        terminal.writeVerboseLine(cacheDisabledReason);\n        return;\n      }\n\n      const { operationSettings, projectChangeAnalyzer } = buildCacheContext;\n      if (!operationSettings || !buildCacheConfiguration) {\n        // Unreachable, since this will have set `cacheDisabledReason`.\n        return;\n      }\n\n      const projectOutputFolderNames: ReadonlyArray<string> = operationSettings.outputFolderNames || [];\n      const additionalProjectOutputFilePaths: ReadonlyArray<string> =\n        operationMetadataManager?.relativeFilepaths || [];\n      const additionalContext: Record<string, string> = {};\n\n      await updateAdditionalContextAsync({\n        operationSettings,\n        additionalContext,\n        projectChangeAnalyzer,\n        terminal,\n        rushProject\n      });\n\n      // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent\n      buildCacheContext.projectBuildCache = await ProjectBuildCache.tryGetProjectBuildCacheAsync({\n        project: rushProject,\n        projectOutputFolderNames,\n        additionalProjectOutputFilePaths,\n        additionalContext,\n        buildCacheConfiguration,\n        terminal,\n        configHash,\n        projectChangeAnalyzer,\n        phaseName: phase.name\n      });\n    }\n\n    return buildCacheContext.projectBuildCache;\n  }\n\n  // Get a ProjectBuildCache only cache/restore log files\n  private async _tryGetLogOnlyProjectBuildCacheAsync({\n    buildCacheContext,\n    rushProject,\n    terminal,\n    configHash,\n    buildCacheConfiguration,\n    cobuildConfiguration,\n    phase,\n    operationMetadataManager\n  }: {\n    buildCacheContext: IOperationBuildCacheContext;\n    buildCacheConfiguration: BuildCacheConfiguration | undefined;\n    cobuildConfiguration: CobuildConfiguration;\n    rushProject: RushConfigurationProject;\n    phase: IPhase;\n    configHash: string;\n    terminal: ITerminal;\n    operationMetadataManager: OperationMetadataManager | undefined;\n  }): Promise<ProjectBuildCache | undefined> {\n    if (!buildCacheConfiguration?.buildCacheEnabled) {\n      return;\n    }\n\n    const { operationSettings, projectChangeAnalyzer } = buildCacheContext;\n\n    const projectOutputFolderNames: ReadonlyArray<string> = operationSettings?.outputFolderNames ?? [];\n    const additionalProjectOutputFilePaths: ReadonlyArray<string> =\n      operationMetadataManager?.relativeFilepaths || [];\n    const additionalContext: Record<string, string> = {\n      // Force the cache to be a log files only cache\n      logFilesOnly: '1'\n    };\n    if (cobuildConfiguration.cobuildContextId) {\n      additionalContext.cobuildContextId = cobuildConfiguration.cobuildContextId;\n    }\n\n    if (operationSettings) {\n      await updateAdditionalContextAsync({\n        operationSettings,\n        additionalContext,\n        projectChangeAnalyzer,\n        terminal,\n        rushProject\n      });\n    }\n\n    const projectBuildCache: ProjectBuildCache | undefined =\n      await ProjectBuildCache.tryGetProjectBuildCacheAsync({\n        project: rushProject,\n        projectOutputFolderNames,\n        additionalProjectOutputFilePaths,\n        additionalContext,\n        buildCacheConfiguration,\n        terminal,\n        configHash,\n        projectChangeAnalyzer,\n        phaseName: phase.name\n      });\n\n    // eslint-disable-next-line require-atomic-updates -- This is guaranteed to not be concurrent\n    buildCacheContext.projectBuildCache = projectBuildCache;\n\n    return projectBuildCache;\n  }\n\n  private async _tryGetCobuildLockAsync({\n    cobuildConfiguration,\n    buildCacheContext,\n    projectBuildCache,\n    packageName,\n    phaseName\n  }: {\n    cobuildConfiguration: CobuildConfiguration | undefined;\n    buildCacheContext: IOperationBuildCacheContext;\n    projectBuildCache: ProjectBuildCache | undefined;\n    packageName: string;\n    phaseName: string;\n  }): Promise<CobuildLock | undefined> {\n    if (!buildCacheContext.cobuildLock) {\n      if (projectBuildCache && cobuildConfiguration?.cobuildFeatureEnabled) {\n        if (!buildCacheContext.cobuildClusterId) {\n          // This should not happen\n          throw new InternalError('Cobuild cluster id is not defined');\n        }\n        buildCacheContext.cobuildLock = new CobuildLock({\n          cobuildConfiguration,\n          projectBuildCache,\n          cobuildClusterId: buildCacheContext.cobuildClusterId,\n          lockExpireTimeInSeconds: PERIODIC_CALLBACK_INTERVAL_IN_SECONDS * 3,\n          packageName,\n          phaseName\n        });\n      }\n    }\n    return buildCacheContext.cobuildLock;\n  }\n\n  private async _createBuildCacheTerminalAsync({\n    record,\n    buildCacheContext,\n    buildCacheEnabled,\n    rushProject,\n    logFilenameIdentifier,\n    quietMode,\n    debugMode\n  }: {\n    record: OperationExecutionRecord;\n    buildCacheContext: IOperationBuildCacheContext;\n    buildCacheEnabled: boolean | undefined;\n    rushProject: RushConfigurationProject;\n    logFilenameIdentifier: string;\n    quietMode: boolean;\n    debugMode: boolean;\n  }): Promise<ITerminal> {\n    const silent: boolean = record.runner.silent;\n    if (silent) {\n      const nullTerminalProvider: NullTerminalProvider = new NullTerminalProvider();\n      return new Terminal(nullTerminalProvider);\n    }\n\n    let cacheConsoleWritable: TerminalWritable;\n    // This creates the writer, only do this if necessary.\n    const collatedWriter: CollatedWriter = record.collatedWriter;\n    const cacheProjectLogWritable: TerminalWritable | undefined =\n      await this._tryGetBuildCacheTerminalWritableAsync({\n        buildCacheContext,\n        buildCacheEnabled,\n        rushProject,\n        logFilenameIdentifier\n      });\n\n    if (quietMode) {\n      const discardTransform: DiscardStdoutTransform = new DiscardStdoutTransform({\n        destination: collatedWriter\n      });\n      const normalizeNewlineTransform: TextRewriterTransform = new TextRewriterTransform({\n        destination: discardTransform,\n        normalizeNewlines: NewlineKind.Lf,\n        ensureNewlineAtEnd: true\n      });\n      cacheConsoleWritable = normalizeNewlineTransform;\n    } else {\n      cacheConsoleWritable = collatedWriter;\n    }\n\n    let cacheCollatedTerminal: CollatedTerminal;\n    if (cacheProjectLogWritable) {\n      const cacheSplitterTransform: SplitterTransform = new SplitterTransform({\n        destinations: [cacheConsoleWritable, cacheProjectLogWritable]\n      });\n      cacheCollatedTerminal = new CollatedTerminal(cacheSplitterTransform);\n    } else {\n      cacheCollatedTerminal = new CollatedTerminal(cacheConsoleWritable);\n    }\n\n    const buildCacheTerminalProvider: CollatedTerminalProvider = new CollatedTerminalProvider(\n      cacheCollatedTerminal,\n      {\n        debugEnabled: debugMode\n      }\n    );\n    return new Terminal(buildCacheTerminalProvider);\n  }\n\n  private async _tryGetBuildCacheTerminalWritableAsync({\n    buildCacheEnabled,\n    rushProject,\n    buildCacheContext,\n    logFilenameIdentifier\n  }: {\n    buildCacheEnabled: boolean | undefined;\n    rushProject: RushConfigurationProject;\n    buildCacheContext: IOperationBuildCacheContext;\n    logFilenameIdentifier: string;\n  }): Promise<TerminalWritable | undefined> {\n    // Only open the *.cache.log file(s) if the cache is enabled.\n    if (!buildCacheEnabled) {\n      return;\n    }\n\n    const logFilePaths: ILogFilePaths = getProjectLogFilePaths({\n      project: rushProject,\n      logFilenameIdentifier: `${logFilenameIdentifier}.cache`\n    });\n\n    buildCacheContext.buildCacheTerminalWritable = await initializeProjectLogFilesAsync({\n      logFilePaths\n    });\n\n    return buildCacheContext.buildCacheTerminalWritable;\n  }\n}\nasync function updateAdditionalContextAsync({\n  operationSettings,\n  additionalContext,\n  projectChangeAnalyzer,\n  terminal,\n  rushProject\n}: {\n  operationSettings: IOperationSettings;\n  additionalContext: Record<string, string>;\n  projectChangeAnalyzer: ProjectChangeAnalyzer;\n  terminal: ITerminal;\n  rushProject: RushConfigurationProject;\n}): Promise<void> {\n  if (operationSettings.dependsOnEnvVars) {\n    for (const varName of operationSettings.dependsOnEnvVars) {\n      additionalContext['$' + varName] = process.env[varName] || '';\n    }\n  }\n\n  if (operationSettings.dependsOnAdditionalFiles) {\n    const repoState: IRawRepoState | undefined =\n      await projectChangeAnalyzer._ensureInitializedAsync(terminal);\n\n    const additionalFiles: Map<string, string> = await getHashesForGlobsAsync(\n      operationSettings.dependsOnAdditionalFiles,\n      rushProject.projectFolder,\n      repoState\n    );\n\n    terminal.writeDebugLine(\n      `Including additional files to calculate build cache hash:\\n  ${Array.from(additionalFiles.keys()).join(\n        '\\n  '\n      )} `\n    );\n\n    for (const [filePath, fileHash] of additionalFiles) {\n      additionalContext['file://' + filePath] = fileHash;\n    }\n  }\n}\n\nexport function clusterOperations(\n  initialClusters: DisjointSet<Operation>,\n  operationBuildCacheMap: Map<Operation, { cacheDisabledReason: string | undefined }>\n): void {\n  // If disjoint set exists, connect build cache disabled project with its consumers\n  for (const [operation, { cacheDisabledReason }] of operationBuildCacheMap) {\n    const { associatedProject: project, associatedPhase: phase } = operation;\n    if (project && phase) {\n      if (cacheDisabledReason && !operation.settings?.allowCobuildWithoutCache) {\n        /**\n         * Group the project build cache disabled with its consumers. This won't affect too much in\n         * a monorepo with high build cache coverage.\n         *\n         * The mental model is that if X disables the cache, and Y depends on X, then:\n         *   1. Y must be built by the same VM that build X;\n         *   2. OR, Y must be rebuilt on each VM that needs it.\n         * Approach 1 is probably the better choice.\n         */\n        for (const consumer of operation.consumers) {\n          initialClusters?.union(operation, consumer);\n        }\n      }\n    }\n  }\n}\n"]}