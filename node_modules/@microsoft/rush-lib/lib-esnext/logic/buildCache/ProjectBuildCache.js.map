{"version":3,"file":"ProjectBuildCache.js","sourceRoot":"","sources":["../../../src/logic/buildCache/ProjectBuildCache.ts"],"names":[],"mappings":"AAAA,4FAA4F;AAC5F,2DAA2D;AAE3D,OAAO,KAAK,IAAI,MAAM,MAAM,CAAC;AAC7B,OAAO,KAAK,MAAM,MAAM,QAAQ,CAAC;AAEjC,OAAO,EAAE,UAAU,EAAmB,aAAa,EAAE,KAAK,EAAE,MAAM,8BAA8B,CAAC;AAKjG,OAAO,EAAE,aAAa,EAAE,MAAM,kBAAkB,CAAC;AAIjD,OAAO,EAAE,aAAa,EAAE,MAAM,+BAA+B,CAAC;AAC9D,OAAO,EAAE,wBAAwB,EAAE,MAAM,oCAAoC,CAAC;AAmB9E,MAAM,OAAO,iBAAiB;IAgB5B,YAAoB,OAA2B,EAAE,OAAkC;QACjF,MAAM,EACJ,uBAAuB,EAAE,EACvB,kBAAkB,EAClB,kBAAkB,EAClB,iBAAiB,EACjB,iBAAiB,EAClB,EACD,OAAO,EACP,wBAAwB,EACxB,gCAAgC,EACjC,GAAG,OAAO,CAAC;QACZ,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,wBAAwB,GAAG,kBAAkB,CAAC;QACnD,IAAI,CAAC,wBAAwB,GAAG,kBAAkB,CAAC;QACnD,IAAI,CAAC,kBAAkB,GAAG,iBAAiB,CAAC;QAC5C,IAAI,CAAC,kBAAkB,GAAG,iBAAiB,CAAC;QAC5C,IAAI,CAAC,yBAAyB,GAAG,wBAAwB,IAAI,EAAE,CAAC;QAChE,IAAI,CAAC,iCAAiC,GAAG,gCAAgC,IAAI,EAAE,CAAC;QAChF,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAEO,MAAM,CAAC,iBAAiB,CAAC,QAAmB;QAClD,IAAI,iBAAiB,CAAC,kBAAkB,KAAK,IAAI,EAAE,CAAC;YAClD,iBAAiB,CAAC,kBAAkB,GAAG,aAAa,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;QACpF,CAAC;QAED,OAAO,iBAAiB,CAAC,kBAAkB,CAAC;IAC9C,CAAC;IAED,IAAW,OAAO;QAChB,OAAO,IAAI,CAAC,QAAQ,CAAC;IACvB,CAAC;IAEM,MAAM,CAAC,KAAK,CAAC,4BAA4B,CAC9C,OAAkC;QAElC,MAAM,OAAO,GAAuB,MAAM,iBAAiB,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;QACtF,OAAO,IAAI,iBAAiB,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACjD,CAAC;IAEM,KAAK,CAAC,wBAAwB,CAAC,QAAmB,EAAE,gBAAyB;QAClF,MAAM,OAAO,GAAuB,gBAAgB,IAAI,IAAI,CAAC,QAAQ,CAAC;QACtE,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,QAAQ,CAAC,gBAAgB,CAAC,kDAAkD,CAAC,CAAC;YAC9E,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC7B,+DAA+D;YAC/D,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,mBAAmB,GACrB,MAAM,IAAI,CAAC,wBAAwB,CAAC,6BAA6B,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACvF,IAAI,gBAAoC,CAAC;QACzC,IAAI,uBAA4C,CAAC;QACjD,IAAI,CAAC,mBAAmB,IAAI,IAAI,CAAC,wBAAwB,EAAE,CAAC;YAC1D,QAAQ,CAAC,gBAAgB,CACvB,sFAAsF,CACvF,CAAC;YAEF,gBAAgB,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,+BAA+B,CACpF,QAAQ,EACR,OAAO,CACR,CAAC;YACF,IAAI,gBAAgB,EAAE,CAAC;gBACrB,IAAI,CAAC;oBACH,mBAAmB,GAAG,MAAM,IAAI,CAAC,wBAAwB,CAAC,2BAA2B,CACnF,QAAQ,EACR,OAAO,EACP,gBAAgB,CACjB,CAAC;oBACF,uBAAuB,GAAG,IAAI,CAAC;gBACjC,CAAC;gBAAC,OAAO,CAAC,EAAE,CAAC;oBACX,uBAAuB,GAAG,KAAK,CAAC;gBAClC,CAAC;YACH,CAAC;QACH,CAAC;QAED,IAAI,CAAC,mBAAmB,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC9C,QAAQ,CAAC,gBAAgB,CAAC,gDAAgD,CAAC,CAAC;YAC5E,OAAO,KAAK,CAAC;QACf,CAAC;QAED,QAAQ,CAAC,SAAS,CAAC,kBAAkB,CAAC,CAAC;QACvC,QAAQ,CAAC,gBAAgB,CAAC,cAAc,OAAO,EAAE,CAAC,CAAC;QAEnD,MAAM,iBAAiB,GAAW,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;QAE9D,uBAAuB;QACvB,QAAQ,CAAC,gBAAgB,CAAC,4BAA4B,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACnG,MAAM,OAAO,CAAC,GAAG,CACf,IAAI,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC,gBAAwB,EAAE,EAAE,CAC9D,UAAU,CAAC,iBAAiB,CAAC,GAAG,iBAAiB,IAAI,gBAAgB,EAAE,CAAC,CACzE,CACF,CAAC;QAEF,MAAM,UAAU,GAA8B,MAAM,iBAAiB,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAClG,IAAI,cAAc,GAAY,KAAK,CAAC;QACpC,IAAI,UAAU,IAAI,mBAAmB,EAAE,CAAC;YACtC,MAAM,WAAW,GAAW,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;YAC7D,MAAM,WAAW,GAAW,MAAM,UAAU,CAAC,aAAa,CAAC;gBACzD,WAAW,EAAE,mBAAmB;gBAChC,gBAAgB,EAAE,iBAAiB;gBACnC,WAAW;aACZ,CAAC,CAAC;YACH,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;gBACtB,cAAc,GAAG,IAAI,CAAC;gBACtB,QAAQ,CAAC,SAAS,CAAC,oDAAoD,CAAC,CAAC;YAC3E,CAAC;iBAAM,CAAC;gBACN,QAAQ,CAAC,gBAAgB,CACvB,iDAAiD;oBAC/C,QAAQ,WAAW,kCAAkC,CACxD,CAAC;YACJ,CAAC;QACH,CAAC;QAED,IAAI,uBAAuB,KAAK,KAAK,EAAE,CAAC;YACtC,QAAQ,CAAC,gBAAgB,CAAC,wEAAwE,CAAC,CAAC;QACtG,CAAC;QAED,OAAO,cAAc,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,qBAAqB,CAAC,QAAmB,EAAE,gBAAyB;;QAC/E,IAAI,CAAC,IAAI,CAAC,kBAAkB,EAAE,CAAC;YAC7B,+DAA+D;YAC/D,OAAO,IAAI,CAAC;QACd,CAAC;QAED,MAAM,OAAO,GAAuB,gBAAgB,IAAI,IAAI,CAAC,QAAQ,CAAC;QACtE,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,QAAQ,CAAC,gBAAgB,CAAC,kDAAkD,CAAC,CAAC;YAC9E,OAAO,KAAK,CAAC;QACf,CAAC;QAED,MAAM,YAAY,GAA8B,MAAM,IAAI,CAAC,4BAA4B,CAAC,QAAQ,CAAC,CAAC;QAClG,IAAI,CAAC,YAAY,EAAE,CAAC;YAClB,OAAO,KAAK,CAAC;QACf,CAAC;QAED,QAAQ,CAAC,gBAAgB,CACvB,iCAAiC,YAAY,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CACrF,CAAC;QAEF,IAAI,mBAAuC,CAAC;QAE5C,MAAM,UAAU,GAA8B,MAAM,iBAAiB,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAClG,IAAI,UAAU,EAAE,CAAC;YACf,MAAM,wBAAwB,GAAW,IAAI,CAAC,wBAAwB,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;YAElG,uFAAuF;YACvF,yFAAyF;YACzF,sEAAsE;YACtE,MAAM,YAAY,GAAW,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YACnE,MAAM,uBAAuB,GAAW,GAAG,wBAAwB,IAAI,YAAY,OAAO,CAAC;YAE3F,MAAM,WAAW,GAAW,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;YAC3D,MAAM,WAAW,GAAW,MAAM,UAAU,CAAC,qCAAqC,CAAC;gBACjF,WAAW,EAAE,uBAAuB;gBACpC,KAAK,EAAE,YAAY,CAAC,eAAe;gBACnC,OAAO,EAAE,IAAI,CAAC,QAAQ;gBACtB,WAAW;aACZ,CAAC,CAAC;YAEH,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;gBACtB,+GAA+G;gBAC/G,IAAI,CAAC;oBACH,MAAM,KAAK,CAAC,mBAAmB,CAAC;wBAC9B,MAAM,EAAE,GAAG,EAAE,CACX,UAAU,CAAC,SAAS,CAAC;4BACnB,UAAU,EAAE,uBAAuB;4BACnC,eAAe,EAAE,wBAAwB;4BACzC,SAAS,EAAE,IAAI;yBAChB,CAAC;wBACJ,UAAU,EAAE,CAAC;wBACb,YAAY,EAAE,GAAG;qBAClB,CAAC,CAAC;gBACL,CAAC;gBAAC,OAAO,SAAS,EAAE,CAAC;oBACnB,IAAI,CAAC;wBACH,MAAM,UAAU,CAAC,eAAe,CAAC,uBAAuB,CAAC,CAAC;oBAC5D,CAAC;oBAAC,OAAO,WAAW,EAAE,CAAC;wBACrB,UAAU;oBACZ,CAAC;oBACD,MAAM,SAAS,CAAC;gBAClB,CAAC;gBACD,mBAAmB,GAAG,wBAAwB,CAAC;YACjD,CAAC;iBAAM,CAAC;gBACN,QAAQ,CAAC,gBAAgB,CACvB,0BAA0B,WAAW,+CAA+C;oBAClF,QAAQ,WAAW,kCAAkC,CACxD,CAAC;gBACF,OAAO,KAAK,CAAC;YACf,CAAC;QACH,CAAC;aAAM,CAAC;YACN,QAAQ,CAAC,gBAAgB,CACvB,oGAAoG;gBAClG,GAAG,wBAAwB,CAAC,oBAAoB,6DAA6D,CAChH,CAAC;YACF,OAAO,KAAK,CAAC;QACf,CAAC;QAED,IAAI,gBAAoC,CAAC;QAEzC,IAAI,yBAAuD,CAAC;QAE5D,uFAAuF;QACvF,+FAA+F;QAC/F,kCAAkC;QAElC,IAAI,MAAA,IAAI,CAAC,wBAAwB,0CAAE,mBAAmB,EAAE,CAAC;YACvD,IAAI,mBAAmB,EAAE,CAAC;gBACxB,gBAAgB,GAAG,MAAM,UAAU,CAAC,qBAAqB,CAAC,mBAAmB,CAAC,CAAC;YACjF,CAAC;iBAAM,CAAC;gBACN,MAAM,IAAI,aAAa,CAAC,gDAAgD,CAAC,CAAC;YAC5E,CAAC;YAED,yBAAyB,GAAG,MAAA,IAAI,CAAC,wBAAwB,0CAAE,2BAA2B,CACpF,QAAQ,EACR,OAAO,EACP,gBAAgB,CACjB,CAAC;QACJ,CAAC;QAED,MAAM,uBAAuB,GAAwB,MAAA,CAAC,MAAM,yBAAyB,CAAC,mCAAI,IAAI,CAAC;QAE/F,MAAM,OAAO,GAAY,uBAAuB,IAAI,CAAC,CAAC,mBAAmB,CAAC;QAC1E,IAAI,OAAO,EAAE,CAAC;YACZ,QAAQ,CAAC,SAAS,CAAC,+BAA+B,CAAC,CAAC;YACpD,QAAQ,CAAC,gBAAgB,CAAC,cAAc,OAAO,EAAE,CAAC,CAAC;QACrD,CAAC;aAAM,IAAI,CAAC,mBAAmB,IAAI,uBAAuB,EAAE,CAAC;YAC3D,QAAQ,CAAC,gBAAgB,CAAC,kCAAkC,CAAC,CAAC;QAChE,CAAC;aAAM,IAAI,mBAAmB,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAC3D,QAAQ,CAAC,gBAAgB,CAAC,kCAAkC,CAAC,CAAC;QAChE,CAAC;aAAM,CAAC;YACN,QAAQ,CAAC,gBAAgB,CAAC,mDAAmD,CAAC,CAAC;QACjF,CAAC;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;;OAIG;IACK,KAAK,CAAC,4BAA4B,CAAC,QAAmB;QAC5D,MAAM,iBAAiB,GAAW,IAAI,CAAC,QAAQ,CAAC,aAAa,CAAC;QAC9D,MAAM,eAAe,GAAa,EAAE,CAAC;QACrC,MAAM,KAAK,GAAuB,EAAE,CAAC;QAErC,MAAM,yBAAyB,GAAa,EAAE,CAAC;QAE/C,IAAI,gBAAgB,GAAY,KAAK,CAAC;QAEtC,qFAAqF;QACrF,SAAS,eAAe,CAAC,YAAoB,EAAE,QAAgB,EAAE,QAAsB;YACrF,KAAK,MAAM,KAAK,IAAI,QAAQ,EAAE,CAAC;gBAC7B,MAAM,iBAAiB,GAAW,GAAG,YAAY,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC;gBAClE,IAAI,KAAK,CAAC,cAAc,EAAE,EAAE,CAAC;oBAC3B,QAAQ,CAAC,UAAU,CACjB,sBAAsB,iBAAiB,0CAA0C,CAClF,CAAC;oBACF,gBAAgB,GAAG,IAAI,CAAC;gBAC1B,CAAC;qBAAM,IAAI,KAAK,CAAC,WAAW,EAAE,EAAE,CAAC;oBAC/B,KAAK,CAAC,IAAI,CAAC,CAAC,iBAAiB,EAAE,GAAG,QAAQ,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gBAC/D,CAAC;qBAAM,CAAC;oBACN,eAAe,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;gBAC1C,CAAC;YACH,CAAC;QACH,CAAC;QAED,kCAAkC;QAClC,KAAK,MAAM,YAAY,IAAI,IAAI,CAAC,yBAAyB,EAAE,CAAC;YAC1D,MAAM,QAAQ,GAAW,GAAG,iBAAiB,IAAI,YAAY,EAAE,CAAC;YAChE,IAAI,CAAC;gBACH,MAAM,QAAQ,GAAiB,MAAM,UAAU,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;gBAC/E,eAAe,CAAC,YAAY,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;gBAClD,+BAA+B;gBAC/B,yBAAyB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAC/C,CAAC;YAAC,OAAO,KAAK,EAAE,CAAC;gBACf,IAAI,CAAC,UAAU,CAAC,eAAe,CAAC,KAAc,CAAC,EAAE,CAAC;oBAChD,MAAM,KAAK,CAAC;gBACd,CAAC;gBAED,2CAA2C;YAC7C,CAAC;QACH,CAAC;QAED,KAAK,MAAM,CAAC,YAAY,EAAE,QAAQ,CAAC,IAAI,KAAK,EAAE,CAAC;YAC7C,MAAM,QAAQ,GAAiB,MAAM,UAAU,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;YAC/E,eAAe,CAAC,YAAY,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACpD,CAAC;QAED,IAAI,gBAAgB,EAAE,CAAC;YACrB,2CAA2C;YAC3C,OAAO,SAAS,CAAC;QACnB,CAAC;QAED,mCAAmC;QACnC,MAAM,KAAK,CAAC,YAAY,CACtB,IAAI,CAAC,iCAAiC,EACtC,KAAK,EAAE,+BAAuC,EAAE,EAAE;YAChD,MAAM,QAAQ,GAAW,GAAG,iBAAiB,IAAI,+BAA+B,EAAE,CAAC;YACnF,MAAM,UAAU,GAAY,MAAM,UAAU,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;YACnE,IAAI,UAAU,EAAE,CAAC;gBACf,eAAe,CAAC,IAAI,CAAC,+BAA+B,CAAC,CAAC;YACxD,CAAC;QACH,CAAC,EACD,EAAE,WAAW,EAAE,EAAE,EAAE,CACpB,CAAC;QAEF,mCAAmC;QACnC,eAAe,CAAC,IAAI,EAAE,CAAC;QAEvB,OAAO;YACL,eAAe;YACf,yBAAyB;SAC1B,CAAC;IACJ,CAAC;IAEO,kBAAkB,CAAC,IAAqB;QAC9C,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,GAAG,IAAI,CAAC,QAAQ,IAAI,IAAI,MAAM,CAAC,CAAC;IACxF,CAAC;IAEO,MAAM,CAAC,KAAK,CAAC,gBAAgB,CAAC,EACpC,qBAAqB,EACrB,OAAO,EACP,QAAQ,EACR,wBAAwB,EACxB,UAAU,EACV,iBAAiB,EACjB,SAAS,EACT,uBAAuB,EAAE,EAAE,eAAe,EAAE,EAClB;QAC1B,gEAAgE;QAChE,kFAAkF;QAClF,wCAAwC;QACxC,+EAA+E;QAC/E,8BAA8B;QAC9B,4EAA4E;QAC5E,gEAAgE;QAChE,iEAAiE;QACjE,kDAAkD;QAClD,oFAAoF;QACpF,6CAA6C;QAC7C,yCAAyC;QACzC,MAAM,aAAa,GAAa,EAAE,CAAC;QACnC,MAAM,iBAAiB,GAAkC,IAAI,GAAG,EAAE,CAAC;QACnE,iBAAiB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAE/B,KAAK,MAAM,gBAAgB,IAAI,iBAAiB,EAAE,CAAC;YACjD,MAAM,YAAY,GAAuB,MAAM,qBAAqB,CAAC,4BAA4B,CAC/F,gBAAgB,EAChB,QAAQ,CACT,CAAC;YACF,IAAI,CAAC,YAAY,EAAE,CAAC;gBAClB,qEAAqE;gBACrE,OAAO,SAAS,CAAC;YACnB,CAAC;iBAAM,CAAC;gBACN,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBACjC,KAAK,MAAM,UAAU,IAAI,gBAAgB,CAAC,kBAAkB,EAAE,CAAC;oBAC7D,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;gBACpC,CAAC;YACH,CAAC;QACH,CAAC;QAED,MAAM,mBAAmB,GAAa,aAAa,CAAC,IAAI,EAAE,CAAC;QAC3D,MAAM,IAAI,GAAgB,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QACpD,gFAAgF;QAChF,IAAI,CAAC,MAAM,CAAC,GAAG,aAAa,CAAC,iBAAiB,EAAE,CAAC,CAAC;QAClD,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QACzC,MAAM,uBAAuB,GAAW,IAAI,CAAC,SAAS,CAAC,wBAAwB,CAAC,CAAC;QACjF,IAAI,CAAC,MAAM,CAAC,uBAAuB,CAAC,CAAC;QACrC,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QACzC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;QACxB,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QACzC,IAAI,iBAAiB,EAAE,CAAC;YACtB,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC;gBACxD,0CAA0C;gBAC1C,EAAE;gBACF,8FAA8F;gBAC9F,2FAA2F;gBAC3F,4FAA4F;gBAC5F,mBAAmB;gBACnB,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG,IAAI,iBAAiB,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;gBAChD,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;YAC3C,CAAC;QACH,CAAC;QACD,KAAK,MAAM,WAAW,IAAI,mBAAmB,EAAE,CAAC;YAC9C,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;YACzB,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,aAAa,CAAC,CAAC;QAC3C,CAAC;QAED,MAAM,gBAAgB,GAAW,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEpD,OAAO,eAAe,CAAC;YACrB,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,gBAAgB;YAChB,SAAS;SACV,CAAC,CAAC;IACL,CAAC;;AAjaD;;;GAGG;AACY,oCAAkB,GAA8C,IAAI,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport * as crypto from 'crypto';\n\nimport { FileSystem, type FolderItem, InternalError, Async } from '@rushstack/node-core-library';\nimport type { ITerminal } from '@rushstack/terminal';\n\nimport type { RushConfigurationProject } from '../../api/RushConfigurationProject';\nimport type { ProjectChangeAnalyzer } from '../ProjectChangeAnalyzer';\nimport { RushConstants } from '../RushConstants';\nimport type { BuildCacheConfiguration } from '../../api/BuildCacheConfiguration';\nimport type { ICloudBuildCacheProvider } from './ICloudBuildCacheProvider';\nimport type { FileSystemBuildCacheProvider } from './FileSystemBuildCacheProvider';\nimport { TarExecutable } from '../../utilities/TarExecutable';\nimport { EnvironmentVariableNames } from '../../api/EnvironmentConfiguration';\n\nexport interface IProjectBuildCacheOptions {\n  buildCacheConfiguration: BuildCacheConfiguration;\n  project: RushConfigurationProject;\n  projectOutputFolderNames: ReadonlyArray<string>;\n  additionalProjectOutputFilePaths?: ReadonlyArray<string>;\n  additionalContext?: Record<string, string>;\n  configHash: string;\n  projectChangeAnalyzer: ProjectChangeAnalyzer;\n  terminal: ITerminal;\n  phaseName: string;\n}\n\ninterface IPathsToCache {\n  filteredOutputFolderNames: string[];\n  outputFilePaths: string[];\n}\n\nexport class ProjectBuildCache {\n  /**\n   * null === we haven't tried to initialize yet\n   * undefined === unable to initialize\n   */\n  private static _tarUtilityPromise: Promise<TarExecutable | undefined> | null = null;\n\n  private readonly _project: RushConfigurationProject;\n  private readonly _localBuildCacheProvider: FileSystemBuildCacheProvider;\n  private readonly _cloudBuildCacheProvider: ICloudBuildCacheProvider | undefined;\n  private readonly _buildCacheEnabled: boolean;\n  private readonly _cacheWriteEnabled: boolean;\n  private readonly _projectOutputFolderNames: ReadonlyArray<string>;\n  private readonly _additionalProjectOutputFilePaths: ReadonlyArray<string>;\n  private _cacheId: string | undefined;\n\n  private constructor(cacheId: string | undefined, options: IProjectBuildCacheOptions) {\n    const {\n      buildCacheConfiguration: {\n        localCacheProvider,\n        cloudCacheProvider,\n        buildCacheEnabled,\n        cacheWriteEnabled\n      },\n      project,\n      projectOutputFolderNames,\n      additionalProjectOutputFilePaths\n    } = options;\n    this._project = project;\n    this._localBuildCacheProvider = localCacheProvider;\n    this._cloudBuildCacheProvider = cloudCacheProvider;\n    this._buildCacheEnabled = buildCacheEnabled;\n    this._cacheWriteEnabled = cacheWriteEnabled;\n    this._projectOutputFolderNames = projectOutputFolderNames || [];\n    this._additionalProjectOutputFilePaths = additionalProjectOutputFilePaths || [];\n    this._cacheId = cacheId;\n  }\n\n  private static _tryGetTarUtility(terminal: ITerminal): Promise<TarExecutable | undefined> {\n    if (ProjectBuildCache._tarUtilityPromise === null) {\n      ProjectBuildCache._tarUtilityPromise = TarExecutable.tryInitializeAsync(terminal);\n    }\n\n    return ProjectBuildCache._tarUtilityPromise;\n  }\n\n  public get cacheId(): string | undefined {\n    return this._cacheId;\n  }\n\n  public static async tryGetProjectBuildCacheAsync(\n    options: IProjectBuildCacheOptions\n  ): Promise<ProjectBuildCache | undefined> {\n    const cacheId: string | undefined = await ProjectBuildCache._getCacheIdAsync(options);\n    return new ProjectBuildCache(cacheId, options);\n  }\n\n  public async tryRestoreFromCacheAsync(terminal: ITerminal, specifiedCacheId?: string): Promise<boolean> {\n    const cacheId: string | undefined = specifiedCacheId || this._cacheId;\n    if (!cacheId) {\n      terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n      return false;\n    }\n\n    if (!this._buildCacheEnabled) {\n      // Skip reading local and cloud build caches, without any noise\n      return false;\n    }\n\n    let localCacheEntryPath: string | undefined =\n      await this._localBuildCacheProvider.tryGetCacheEntryPathByIdAsync(terminal, cacheId);\n    let cacheEntryBuffer: Buffer | undefined;\n    let updateLocalCacheSuccess: boolean | undefined;\n    if (!localCacheEntryPath && this._cloudBuildCacheProvider) {\n      terminal.writeVerboseLine(\n        'This project was not found in the local build cache. Querying the cloud build cache.'\n      );\n\n      cacheEntryBuffer = await this._cloudBuildCacheProvider.tryGetCacheEntryBufferByIdAsync(\n        terminal,\n        cacheId\n      );\n      if (cacheEntryBuffer) {\n        try {\n          localCacheEntryPath = await this._localBuildCacheProvider.trySetCacheEntryBufferAsync(\n            terminal,\n            cacheId,\n            cacheEntryBuffer\n          );\n          updateLocalCacheSuccess = true;\n        } catch (e) {\n          updateLocalCacheSuccess = false;\n        }\n      }\n    }\n\n    if (!localCacheEntryPath && !cacheEntryBuffer) {\n      terminal.writeVerboseLine('This project was not found in the build cache.');\n      return false;\n    }\n\n    terminal.writeLine('Build cache hit.');\n    terminal.writeVerboseLine(`Cache key: ${cacheId}`);\n\n    const projectFolderPath: string = this._project.projectFolder;\n\n    // Purge output folders\n    terminal.writeVerboseLine(`Clearing cached folders: ${this._projectOutputFolderNames.join(', ')}`);\n    await Promise.all(\n      this._projectOutputFolderNames.map((outputFolderName: string) =>\n        FileSystem.deleteFolderAsync(`${projectFolderPath}/${outputFolderName}`)\n      )\n    );\n\n    const tarUtility: TarExecutable | undefined = await ProjectBuildCache._tryGetTarUtility(terminal);\n    let restoreSuccess: boolean = false;\n    if (tarUtility && localCacheEntryPath) {\n      const logFilePath: string = this._getTarLogFilePath('untar');\n      const tarExitCode: number = await tarUtility.tryUntarAsync({\n        archivePath: localCacheEntryPath,\n        outputFolderPath: projectFolderPath,\n        logFilePath\n      });\n      if (tarExitCode === 0) {\n        restoreSuccess = true;\n        terminal.writeLine('Successfully restored output from the build cache.');\n      } else {\n        terminal.writeWarningLine(\n          'Unable to restore output from the build cache. ' +\n            `See \"${logFilePath}\" for logs from the tar process.`\n        );\n      }\n    }\n\n    if (updateLocalCacheSuccess === false) {\n      terminal.writeWarningLine('Unable to update the local build cache with data from the cloud cache.');\n    }\n\n    return restoreSuccess;\n  }\n\n  public async trySetCacheEntryAsync(terminal: ITerminal, specifiedCacheId?: string): Promise<boolean> {\n    if (!this._cacheWriteEnabled) {\n      // Skip writing local and cloud build caches, without any noise\n      return true;\n    }\n\n    const cacheId: string | undefined = specifiedCacheId || this._cacheId;\n    if (!cacheId) {\n      terminal.writeWarningLine('Unable to get cache ID. Ensure Git is installed.');\n      return false;\n    }\n\n    const filesToCache: IPathsToCache | undefined = await this._tryCollectPathsToCacheAsync(terminal);\n    if (!filesToCache) {\n      return false;\n    }\n\n    terminal.writeVerboseLine(\n      `Caching build output folders: ${filesToCache.filteredOutputFolderNames.join(', ')}`\n    );\n\n    let localCacheEntryPath: string | undefined;\n\n    const tarUtility: TarExecutable | undefined = await ProjectBuildCache._tryGetTarUtility(terminal);\n    if (tarUtility) {\n      const finalLocalCacheEntryPath: string = this._localBuildCacheProvider.getCacheEntryPath(cacheId);\n\n      // Derive the temp file from the destination path to ensure they are on the same volume\n      // In the case of a shared network drive containing the build cache, we also need to make\n      // sure the the temp path won't be shared by two parallel rush builds.\n      const randomSuffix: string = crypto.randomBytes(8).toString('hex');\n      const tempLocalCacheEntryPath: string = `${finalLocalCacheEntryPath}-${randomSuffix}.temp`;\n\n      const logFilePath: string = this._getTarLogFilePath('tar');\n      const tarExitCode: number = await tarUtility.tryCreateArchiveFromProjectPathsAsync({\n        archivePath: tempLocalCacheEntryPath,\n        paths: filesToCache.outputFilePaths,\n        project: this._project,\n        logFilePath\n      });\n\n      if (tarExitCode === 0) {\n        // Move after the archive is finished so that if the process is interrupted we aren't left with an invalid file\n        try {\n          await Async.runWithRetriesAsync({\n            action: () =>\n              FileSystem.moveAsync({\n                sourcePath: tempLocalCacheEntryPath,\n                destinationPath: finalLocalCacheEntryPath,\n                overwrite: true\n              }),\n            maxRetries: 2,\n            retryDelayMs: 500\n          });\n        } catch (moveError) {\n          try {\n            await FileSystem.deleteFileAsync(tempLocalCacheEntryPath);\n          } catch (deleteError) {\n            // Ignored\n          }\n          throw moveError;\n        }\n        localCacheEntryPath = finalLocalCacheEntryPath;\n      } else {\n        terminal.writeWarningLine(\n          `\"tar\" exited with code ${tarExitCode} while attempting to create the cache entry. ` +\n            `See \"${logFilePath}\" for logs from the tar process.`\n        );\n        return false;\n      }\n    } else {\n      terminal.writeWarningLine(\n        `Unable to locate \"tar\". Please ensure that \"tar\" is on your PATH environment variable, or set the ` +\n          `${EnvironmentVariableNames.RUSH_TAR_BINARY_PATH} environment variable to the full path to the \"tar\" binary.`\n      );\n      return false;\n    }\n\n    let cacheEntryBuffer: Buffer | undefined;\n\n    let setCloudCacheEntryPromise: Promise<boolean> | undefined;\n\n    // Note that \"writeAllowed\" settings (whether in config or environment) always apply to\n    // the configured CLOUD cache. If the cache is enabled, rush is always allowed to read from and\n    // write to the local build cache.\n\n    if (this._cloudBuildCacheProvider?.isCacheWriteAllowed) {\n      if (localCacheEntryPath) {\n        cacheEntryBuffer = await FileSystem.readFileToBufferAsync(localCacheEntryPath);\n      } else {\n        throw new InternalError('Expected the local cache entry path to be set.');\n      }\n\n      setCloudCacheEntryPromise = this._cloudBuildCacheProvider?.trySetCacheEntryBufferAsync(\n        terminal,\n        cacheId,\n        cacheEntryBuffer\n      );\n    }\n\n    const updateCloudCacheSuccess: boolean | undefined = (await setCloudCacheEntryPromise) ?? true;\n\n    const success: boolean = updateCloudCacheSuccess && !!localCacheEntryPath;\n    if (success) {\n      terminal.writeLine('Successfully set cache entry.');\n      terminal.writeVerboseLine(`Cache key: ${cacheId}`);\n    } else if (!localCacheEntryPath && updateCloudCacheSuccess) {\n      terminal.writeWarningLine('Unable to set local cache entry.');\n    } else if (localCacheEntryPath && !updateCloudCacheSuccess) {\n      terminal.writeWarningLine('Unable to set cloud cache entry.');\n    } else {\n      terminal.writeWarningLine('Unable to set both cloud and local cache entries.');\n    }\n\n    return success;\n  }\n\n  /**\n   * Walks the declared output folders of the project and collects a list of files.\n   * @returns The list of output files as project-relative paths, or `undefined` if a\n   *   symbolic link was encountered.\n   */\n  private async _tryCollectPathsToCacheAsync(terminal: ITerminal): Promise<IPathsToCache | undefined> {\n    const projectFolderPath: string = this._project.projectFolder;\n    const outputFilePaths: string[] = [];\n    const queue: [string, string][] = [];\n\n    const filteredOutputFolderNames: string[] = [];\n\n    let hasSymbolicLinks: boolean = false;\n\n    // Adds child directories to the queue, files to the path list, and bails on symlinks\n    function processChildren(relativePath: string, diskPath: string, children: FolderItem[]): void {\n      for (const child of children) {\n        const childRelativePath: string = `${relativePath}/${child.name}`;\n        if (child.isSymbolicLink()) {\n          terminal.writeError(\n            `Unable to include \"${childRelativePath}\" in build cache. It is a symbolic link.`\n          );\n          hasSymbolicLinks = true;\n        } else if (child.isDirectory()) {\n          queue.push([childRelativePath, `${diskPath}/${child.name}`]);\n        } else {\n          outputFilePaths.push(childRelativePath);\n        }\n      }\n    }\n\n    // Handle declared output folders.\n    for (const outputFolder of this._projectOutputFolderNames) {\n      const diskPath: string = `${projectFolderPath}/${outputFolder}`;\n      try {\n        const children: FolderItem[] = await FileSystem.readFolderItemsAsync(diskPath);\n        processChildren(outputFolder, diskPath, children);\n        // The folder exists, record it\n        filteredOutputFolderNames.push(outputFolder);\n      } catch (error) {\n        if (!FileSystem.isNotExistError(error as Error)) {\n          throw error;\n        }\n\n        // If the folder does not exist, ignore it.\n      }\n    }\n\n    for (const [relativePath, diskPath] of queue) {\n      const children: FolderItem[] = await FileSystem.readFolderItemsAsync(diskPath);\n      processChildren(relativePath, diskPath, children);\n    }\n\n    if (hasSymbolicLinks) {\n      // Symbolic links do not round-trip safely.\n      return undefined;\n    }\n\n    // Add additional output file paths\n    await Async.forEachAsync(\n      this._additionalProjectOutputFilePaths,\n      async (additionalProjectOutputFilePath: string) => {\n        const fullPath: string = `${projectFolderPath}/${additionalProjectOutputFilePath}`;\n        const pathExists: boolean = await FileSystem.existsAsync(fullPath);\n        if (pathExists) {\n          outputFilePaths.push(additionalProjectOutputFilePath);\n        }\n      },\n      { concurrency: 10 }\n    );\n\n    // Ensure stable output path order.\n    outputFilePaths.sort();\n\n    return {\n      outputFilePaths,\n      filteredOutputFolderNames\n    };\n  }\n\n  private _getTarLogFilePath(mode: 'tar' | 'untar'): string {\n    return path.join(this._project.projectRushTempFolder, `${this._cacheId}.${mode}.log`);\n  }\n\n  private static async _getCacheIdAsync({\n    projectChangeAnalyzer,\n    project,\n    terminal,\n    projectOutputFolderNames,\n    configHash,\n    additionalContext,\n    phaseName,\n    buildCacheConfiguration: { getCacheEntryId }\n  }: IProjectBuildCacheOptions): Promise<string | undefined> {\n    // The project state hash is calculated in the following method:\n    // - The current project's hash (see ProjectChangeAnalyzer.getProjectStateHash) is\n    //   calculated and appended to an array\n    // - The current project's recursive dependency projects' hashes are calculated\n    //   and appended to the array\n    // - A SHA1 hash is created and the following data is fed into it, in order:\n    //   1. The JSON-serialized list of output folder names for this\n    //      project (see ProjectBuildCache._projectOutputFolderNames)\n    //   2. The configHash from the operation's runner\n    //   3. Each dependency project hash (from the array constructed in previous steps),\n    //      in sorted alphanumerical-sorted order\n    // - A hex digest of the hash is returned\n    const projectStates: string[] = [];\n    const projectsToProcess: Set<RushConfigurationProject> = new Set();\n    projectsToProcess.add(project);\n\n    for (const projectToProcess of projectsToProcess) {\n      const projectState: string | undefined = await projectChangeAnalyzer._tryGetProjectStateHashAsync(\n        projectToProcess,\n        terminal\n      );\n      if (!projectState) {\n        // If we hit any projects with unknown state, return unknown cache ID\n        return undefined;\n      } else {\n        projectStates.push(projectState);\n        for (const dependency of projectToProcess.dependencyProjects) {\n          projectsToProcess.add(dependency);\n        }\n      }\n    }\n\n    const sortedProjectStates: string[] = projectStates.sort();\n    const hash: crypto.Hash = crypto.createHash('sha1');\n    // This value is used to force cache bust when the build cache algorithm changes\n    hash.update(`${RushConstants.buildCacheVersion}`);\n    hash.update(RushConstants.hashDelimiter);\n    const serializedOutputFolders: string = JSON.stringify(projectOutputFolderNames);\n    hash.update(serializedOutputFolders);\n    hash.update(RushConstants.hashDelimiter);\n    hash.update(configHash);\n    hash.update(RushConstants.hashDelimiter);\n    if (additionalContext) {\n      for (const key of Object.keys(additionalContext).sort()) {\n        // Add additional context keys and values.\n        //\n        // This choice (to modify the hash for every key regardless of whether a value is set) implies\n        // that just _adding_ an env var to the list of dependsOnEnvVars will modify its hash. This\n        // seems appropriate, because this behavior is consistent whether or not the env var happens\n        // to have a value.\n        hash.update(`${key}=${additionalContext[key]}`);\n        hash.update(RushConstants.hashDelimiter);\n      }\n    }\n    for (const projectHash of sortedProjectStates) {\n      hash.update(projectHash);\n      hash.update(RushConstants.hashDelimiter);\n    }\n\n    const projectStateHash: string = hash.digest('hex');\n\n    return getCacheEntryId({\n      projectName: project.packageName,\n      projectStateHash,\n      phaseName\n    });\n  }\n}\n"]}