// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import { RushConstants } from '../RushConstants';
import { NullOperationRunner } from './NullOperationRunner';
import { convertSlashesForWindows, ShellOperationRunner } from './ShellOperationRunner';
import { OperationStatus } from './OperationStatus';
export const PLUGIN_NAME = 'ShellOperationRunnerPlugin';
/**
 * Core phased command plugin that provides the functionality for executing an operation via shell command.
 */
export class ShellOperationRunnerPlugin {
    apply(hooks) {
        hooks.createOperations.tap(PLUGIN_NAME, createShellOperations);
    }
}
function createShellOperations(operations, context) {
    const { rushConfiguration } = context;
    const getCustomParameterValuesForPhase = getCustomParameterValuesByPhase();
    for (const operation of operations) {
        const { associatedPhase: phase, associatedProject: project } = operation;
        if (phase && project && !operation.runner) {
            // This is a shell command. In the future, may consider having a property on the initial operation
            // to specify a runner type requested in rush-project.json
            const customParameterValues = getCustomParameterValuesForPhase(phase);
            const displayName = getDisplayName(phase, project);
            const rawCommandToRun = getScriptToRun(project, phase.name, phase.shellCommand);
            const commandToRun = rawCommandToRun !== undefined ? formatCommand(rawCommandToRun, customParameterValues) : undefined;
            operation.runner = initializeShellOperationRunner({
                phase,
                project,
                displayName,
                commandToRun,
                rushConfiguration
            });
        }
    }
    return operations;
}
export function initializeShellOperationRunner(options) {
    const { phase, project, rushConfiguration, commandToRun, displayName } = options;
    if (commandToRun === undefined && phase.missingScriptBehavior === 'error') {
        throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);
    }
    if (commandToRun) {
        return new ShellOperationRunner({
            commandToRun: commandToRun || '',
            displayName,
            phase,
            rushConfiguration,
            rushProject: project
        });
    }
    else {
        // Empty build script indicates a no-op, so use a no-op runner
        return new NullOperationRunner({
            name: displayName,
            result: OperationStatus.NoOp,
            silent: phase.missingScriptBehavior === 'silent'
        });
    }
}
export function getScriptToRun(rushProject, commandToRun, shellCommand) {
    const { scripts } = rushProject.packageJson;
    const rawCommand = shellCommand !== null && shellCommand !== void 0 ? shellCommand : scripts === null || scripts === void 0 ? void 0 : scripts[commandToRun];
    if (rawCommand === undefined || rawCommand === null) {
        return undefined;
    }
    return rawCommand;
}
/**
 * Memoizer for custom parameter values by phase
 * @returns A function that returns the custom parameter values for a given phase
 */
export function getCustomParameterValuesByPhase() {
    const customParametersByPhase = new Map();
    function getCustomParameterValuesForPhase(phase) {
        let customParameterValues = customParametersByPhase.get(phase);
        if (!customParameterValues) {
            customParameterValues = [];
            for (const tsCommandLineParameter of phase.associatedParameters) {
                tsCommandLineParameter.appendToArgList(customParameterValues);
            }
            customParametersByPhase.set(phase, customParameterValues);
        }
        return customParameterValues;
    }
    return getCustomParameterValuesForPhase;
}
export function formatCommand(rawCommand, customParameterValues) {
    if (!rawCommand) {
        return '';
    }
    else {
        const fullCommand = `${rawCommand} ${customParameterValues.join(' ')}`;
        return process.platform === 'win32' ? convertSlashesForWindows(fullCommand) : fullCommand;
    }
}
export function getDisplayName(phase, project) {
    if (phase.isSynthetic) {
        // Because this is a synthetic phase, just use the project name because there aren't any other phases
        return project.packageName;
    }
    else {
        const phaseNameWithoutPrefix = phase.name.slice(RushConstants.phaseNamePrefix.length);
        return `${project.packageName} (${phaseNameWithoutPrefix})`;
    }
}
//# sourceMappingURL=ShellOperationRunnerPlugin.js.map