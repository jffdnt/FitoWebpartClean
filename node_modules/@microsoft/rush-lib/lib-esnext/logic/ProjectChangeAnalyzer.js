// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
import * as path from 'path';
import * as crypto from 'crypto';
import ignore from 'ignore';
import { getRepoChanges, getRepoRoot, getRepoStateAsync } from '@rushstack/package-deps-hash';
import { Path, FileSystem, Async } from '@rushstack/node-core-library';
import { RushProjectConfiguration } from '../api/RushProjectConfiguration';
import { Git } from './Git';
import { BaseProjectShrinkwrapFile } from './base/BaseProjectShrinkwrapFile';
import { RushConstants } from './RushConstants';
import { PnpmShrinkwrapFile } from './pnpm/PnpmShrinkwrapFile';
import { UNINITIALIZED } from '../utilities/Utilities';
/**
 * @beta
 */
export class ProjectChangeAnalyzer {
    constructor(rushConfiguration) {
        /**
         * UNINITIALIZED === we haven't looked
         * undefined === data isn't available (i.e. - git isn't present)
         */
        this._data = UNINITIALIZED;
        this._filteredData = new Map();
        this._projectStateCache = new Map();
        this._rushConfiguration = rushConfiguration;
        this._git = new Git(this._rushConfiguration);
    }
    /**
     * Try to get a list of the specified project's dependencies and their hashes.
     *
     * @remarks
     * If the data can't be generated (i.e. - if Git is not present) this returns undefined.
     *
     * @internal
     */
    async _tryGetProjectDependenciesAsync(project, terminal) {
        // Check the cache for any existing data
        let filteredProjectData = this._filteredData.get(project);
        if (filteredProjectData) {
            return filteredProjectData;
        }
        const data = await this._ensureInitializedAsync(terminal);
        if (!data) {
            return undefined;
        }
        const { projectState, rootDir } = data;
        if (projectState === undefined) {
            return undefined;
        }
        const unfilteredProjectData = projectState.get(project);
        if (!unfilteredProjectData) {
            throw new Error(`Project "${project.packageName}" does not exist in the current Rush configuration.`);
        }
        filteredProjectData = await this._filterProjectDataAsync(project, unfilteredProjectData, rootDir, terminal);
        this._filteredData.set(project, filteredProjectData);
        return filteredProjectData;
    }
    /**
     * @internal
     */
    async _ensureInitializedAsync(terminal) {
        if (this._data === UNINITIALIZED) {
            this._data = await this._getDataAsync(terminal);
        }
        return this._data;
    }
    /**
     * The project state hash is calculated in the following way:
     * - Project dependencies are collected (see ProjectChangeAnalyzer.getPackageDeps)
     *   - If project dependencies cannot be collected (i.e. - if Git isn't available),
     *     this function returns `undefined`
     * - The (path separator normalized) repo-root-relative dependencies' file paths are sorted
     * - A SHA1 hash is created and each (sorted) file path is fed into the hash and then its
     *   Git SHA is fed into the hash
     * - A hex digest of the hash is returned
     *
     * @internal
     */
    async _tryGetProjectStateHashAsync(project, terminal) {
        let projectState = this._projectStateCache.get(project);
        if (!projectState) {
            const packageDeps = await this._tryGetProjectDependenciesAsync(project, terminal);
            if (!packageDeps) {
                return undefined;
            }
            else {
                const sortedPackageDepsFiles = Array.from(packageDeps.keys()).sort();
                const hash = crypto.createHash('sha1');
                for (const packageDepsFile of sortedPackageDepsFiles) {
                    hash.update(packageDepsFile);
                    hash.update(RushConstants.hashDelimiter);
                    hash.update(packageDeps.get(packageDepsFile));
                    hash.update(RushConstants.hashDelimiter);
                }
                projectState = hash.digest('hex');
                this._projectStateCache.set(project, projectState);
            }
        }
        return projectState;
    }
    async _filterProjectDataAsync(project, unfilteredProjectData, rootDir, terminal) {
        const ignoreMatcher = await this._getIgnoreMatcherForProjectAsync(project, terminal);
        if (!ignoreMatcher) {
            return unfilteredProjectData;
        }
        const projectKey = path.relative(rootDir, project.projectFolder);
        const projectKeyLength = projectKey.length + 1;
        // At this point, `filePath` is guaranteed to start with `projectKey`, so
        // we can safely slice off the first N characters to get the file path relative to the
        // root of the project.
        const filteredProjectData = new Map();
        for (const [filePath, value] of unfilteredProjectData) {
            const relativePath = filePath.slice(projectKeyLength);
            if (!ignoreMatcher.ignores(relativePath)) {
                // Add the file path to the filtered data if it is not ignored
                filteredProjectData.set(filePath, value);
            }
        }
        return filteredProjectData;
    }
    /**
     * Gets a list of projects that have changed in the current state of the repo
     * when compared to the specified branch, optionally taking the shrinkwrap and settings in
     * the rush-project.json file into consideration.
     */
    async getChangedProjectsAsync(options) {
        const { _rushConfiguration: rushConfiguration } = this;
        const { targetBranchName, terminal, includeExternalDependencies, enableFiltering, shouldFetch } = options;
        const gitPath = this._git.getGitPathOrThrow();
        const repoRoot = getRepoRoot(rushConfiguration.rushJsonFolder);
        // if the given targetBranchName is a commit, we assume it is the merge base
        const IsTargetBranchACommit = await this._git.determineIfRefIsACommitAsync(targetBranchName);
        const mergeCommit = IsTargetBranchACommit
            ? targetBranchName
            : await this._git.getMergeBaseAsync(targetBranchName, terminal, shouldFetch);
        const repoChanges = getRepoChanges(repoRoot, mergeCommit, gitPath);
        const changedProjects = new Set();
        if (includeExternalDependencies) {
            // Even though changing the installed version of a nested dependency merits a change file,
            // ignore lockfile changes for `rush change` for the moment
            const currentVariant = await this._rushConfiguration.getCurrentlyInstalledVariantAsync();
            const fullShrinkwrapPath = rushConfiguration.defaultSubspace.getCommittedShrinkwrapFilePath(currentVariant);
            const relativeShrinkwrapFilePath = Path.convertToSlashes(path.relative(repoRoot, fullShrinkwrapPath));
            const shrinkwrapStatus = repoChanges.get(relativeShrinkwrapFilePath);
            if (shrinkwrapStatus) {
                if (shrinkwrapStatus.status !== 'M') {
                    terminal.writeLine(`Lockfile was created or deleted. Assuming all projects are affected.`);
                    return new Set(rushConfiguration.projects);
                }
                const { packageManager } = rushConfiguration;
                if (packageManager === 'pnpm') {
                    const currentShrinkwrap = PnpmShrinkwrapFile.loadFromFile(fullShrinkwrapPath);
                    if (!currentShrinkwrap) {
                        throw new Error(`Unable to obtain current shrinkwrap file.`);
                    }
                    const oldShrinkwrapText = await this._git.getBlobContentAsync({
                        // <ref>:<path> syntax: https://git-scm.com/docs/gitrevisions
                        blobSpec: `${mergeCommit}:${relativeShrinkwrapFilePath}`,
                        repositoryRoot: repoRoot
                    });
                    const oldShrinkWrap = PnpmShrinkwrapFile.loadFromString(oldShrinkwrapText);
                    for (const project of rushConfiguration.projects) {
                        if (currentShrinkwrap
                            .getProjectShrinkwrap(project)
                            .hasChanges(oldShrinkWrap.getProjectShrinkwrap(project))) {
                            changedProjects.add(project);
                        }
                    }
                }
                else {
                    terminal.writeLine(`Lockfile has changed and lockfile content comparison is only supported for pnpm. Assuming all projects are affected.`);
                    return new Set(rushConfiguration.projects);
                }
            }
        }
        const changesByProject = new Map();
        const lookup = rushConfiguration.getProjectLookupForRoot(repoRoot);
        for (const [file, diffStatus] of repoChanges) {
            const project = lookup.findChildPath(file);
            if (project) {
                if (changedProjects.has(project)) {
                    // Lockfile changes cannot be ignored via rush-project.json
                    continue;
                }
                if (enableFiltering) {
                    let projectChanges = changesByProject.get(project);
                    if (!projectChanges) {
                        projectChanges = new Map();
                        changesByProject.set(project, projectChanges);
                    }
                    projectChanges.set(file, diffStatus);
                }
                else {
                    changedProjects.add(project);
                }
            }
        }
        if (enableFiltering) {
            // Reading rush-project.json may be problematic if, e.g. rush install has not yet occurred and rigs are in use
            await Async.forEachAsync(changesByProject, async ([project, projectChanges]) => {
                const filteredChanges = await this._filterProjectDataAsync(project, projectChanges, repoRoot, terminal);
                if (filteredChanges.size > 0) {
                    changedProjects.add(project);
                }
            }, { concurrency: 10 });
        }
        return changedProjects;
    }
    async _getDataAsync(terminal) {
        const repoState = await this._getRepoDepsAsync(terminal);
        if (!repoState) {
            // Mark as resolved, but no data
            return {
                projectState: undefined,
                rootDir: this._rushConfiguration.rushJsonFolder,
                rawHashes: new Map()
            };
        }
        const lookup = this._rushConfiguration.getProjectLookupForRoot(repoState.rootDir);
        const projectHashDeps = new Map();
        for (const project of this._rushConfiguration.projects) {
            projectHashDeps.set(project, new Map());
        }
        const { hashes: repoDeps, rootDir } = repoState;
        // Currently, only pnpm handles project shrinkwraps
        if (this._rushConfiguration.packageManager !== 'pnpm') {
            const currentVariant = await this._rushConfiguration.getCurrentlyInstalledVariantAsync();
            // Add the shrinkwrap file to every project's dependencies
            const shrinkwrapFile = Path.convertToSlashes(path.relative(rootDir, this._rushConfiguration.defaultSubspace.getCommittedShrinkwrapFilePath(currentVariant)));
            const shrinkwrapHash = repoDeps.get(shrinkwrapFile);
            for (const projectDeps of projectHashDeps.values()) {
                if (shrinkwrapHash) {
                    projectDeps.set(shrinkwrapFile, shrinkwrapHash);
                }
            }
        }
        // Sort each project folder into its own package deps hash
        for (const [filePath, fileHash] of repoDeps) {
            // lookups in findChildPath are O(K)
            // K being the maximum folder depth of any project in rush.json (usually on the order of 3)
            const owningProject = lookup.findChildPath(filePath);
            if (owningProject) {
                const owningProjectHashDeps = projectHashDeps.get(owningProject);
                owningProjectHashDeps.set(filePath, fileHash);
            }
        }
        return {
            projectState: projectHashDeps,
            rootDir,
            rawHashes: repoState.hashes
        };
    }
    async _getIgnoreMatcherForProjectAsync(project, terminal) {
        const incrementalBuildIgnoredGlobs = await RushProjectConfiguration.tryLoadIgnoreGlobsForProjectAsync(project, terminal);
        if (incrementalBuildIgnoredGlobs && incrementalBuildIgnoredGlobs.length) {
            const ignoreMatcher = ignore();
            ignoreMatcher.add(incrementalBuildIgnoredGlobs);
            return ignoreMatcher;
        }
    }
    async _getRepoDepsAsync(terminal) {
        try {
            const gitPath = this._git.getGitPathOrThrow();
            if (this._git.isPathUnderGitWorkingTree()) {
                // Do not use getGitInfo().root; it is the root of the *primary* worktree, not the *current* one.
                const rootDir = getRepoRoot(this._rushConfiguration.rushJsonFolder, gitPath);
                // Load the package deps hash for the whole repository
                // Include project shrinkwrap files as part of the computation
                const additionalFilesToHash = [];
                if (this._rushConfiguration.packageManager === 'pnpm') {
                    await Async.forEachAsync(this._rushConfiguration.projects, async (project) => {
                        const projectShrinkwrapFilePath = BaseProjectShrinkwrapFile.getFilePathForProject(project);
                        if (!(await FileSystem.existsAsync(projectShrinkwrapFilePath))) {
                            // Missing shrinkwrap of subspace project is allowed because subspace projects can be partial installed
                            if (this._rushConfiguration.subspacesFeatureEnabled) {
                                return;
                            }
                            throw new Error(`A project dependency file (${projectShrinkwrapFilePath}) is missing. You may need to run ` +
                                '"rush install" or "rush update".');
                        }
                        const relativeProjectShrinkwrapFilePath = Path.convertToSlashes(path.relative(rootDir, projectShrinkwrapFilePath));
                        additionalFilesToHash.push(relativeProjectShrinkwrapFilePath);
                    });
                }
                const hashes = await getRepoStateAsync(rootDir, additionalFilesToHash, gitPath);
                return {
                    gitPath,
                    hashes,
                    rootDir
                };
            }
            else {
                return undefined;
            }
        }
        catch (e) {
            // If getPackageDeps fails, don't fail the whole build. Treat this case as if we don't know anything about
            // the state of the files in the repo. This can happen if the environment doesn't have Git.
            terminal.writeWarningLine(`Error calculating the state of the repo. (inner error: ${e}). Continuing without diffing files.`);
            return undefined;
        }
    }
}
//# sourceMappingURL=ProjectChangeAnalyzer.js.map