"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortableList = exports.DRAG_HANDLE_TAG = exports.DRAG_LEAF_TAG = void 0;
var tslib_1 = require("tslib");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var sp_component_utilities_1 = require("@ms/sp-component-utilities");
var sp_telemetry_1 = require("@ms/sp-telemetry");
var React = tslib_1.__importStar(require("react"));
exports.DRAG_LEAF_TAG = 'drag-leaf';
exports.DRAG_HANDLE_TAG = 'drag-handler';
var suffix = Math.random().toString().substr(2, 5);
function SortableList(props) {
    var _a;
    var listRef = React.useRef(null);
    var sortableRef = React.useRef(undefined);
    React.useEffect(function () {
        var isMounted = true;
        if (props.displayMode === sp_core_library_1.DisplayMode.Edit && props.onReorderItem && listRef.current) {
            // Exclude the elements without `DRAG_LEAF_TAG` from sortable animation.
            // The workaround here is to always set it `animated` field to exclude it.
            for (var i = 0; i < listRef.current.children.length; i++) {
                var child = listRef.current.children.item(i);
                if (child && child.querySelector("[data-drag-tag=".concat(exports.DRAG_LEAF_TAG, "]")) === null) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    child.animated = -1;
                }
            }
            // Sortable only support class name for handler. Here is a workaround to move the attribute to class list.
            var handlerClassName_1 = "".concat(exports.DRAG_HANDLE_TAG, "-").concat(suffix);
            var dragHandlerSelector = "[data-drag-handle=".concat(exports.DRAG_HANDLE_TAG, "]");
            var elements = [].slice.apply(listRef.current.querySelectorAll(dragHandlerSelector));
            elements.forEach(function (handler) {
                handler.classList.add(handlerClassName_1);
            });
            // Set forceFallback on IE and Edge. See details in https://onedrive.visualstudio.com/SOX/_workitems/edit/620195
            var browser = sp_core_library_1._BrowserDetection.getBrowserInformation().browser;
            var forceFallback_1 = browser === sp_core_library_1._Browser.IE || browser === sp_core_library_1._Browser.Edge;
            var monitor_1 = new sp_telemetry_1._QosMonitor('SortableList.createSortable');
            sp_component_utilities_1.SortableLoader.GetSortable()
                .then(function (module) {
                var _a;
                if (isMounted) {
                    sortableRef.current = module.create(listRef.current, {
                        forceFallback: forceFallback_1,
                        handle: ".".concat(handlerClassName_1),
                        onStart: handleStart,
                        onEnd: handleEnd,
                        animation: 200
                    });
                }
                else {
                    (_a = sortableRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
                    sortableRef.current = undefined;
                }
                monitor_1.writeSuccess();
            })
                .catch(function (error) {
                monitor_1.writeUnexpectedFailure(undefined, error);
                throw error;
            });
        }
        return function () {
            var _a;
            isMounted = false;
            (_a = sortableRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
            sortableRef.current = undefined;
        };
    });
    function handleStart() {
        if (listRef.current) {
            listRef.current.classList.add('dragging');
        }
    }
    function handleEnd(event) {
        // This is a very tricky workaround to mitigate webkit bug: https://bugs.webkit.org/show_bug.cgi?id=134555
        // After user drops the element and moves the mouse a little bit, it considers the dragging action completes.
        // The class `sortable` and `dragging` can be leveraged to skip dragging styles to mitigate the bug.
        document.body.addEventListener('mousemove', function () {
            if (listRef.current) {
                listRef.current.classList.remove('dragging');
            }
        }, { once: true });
        var oldIndex = event.oldIndex;
        var newIndex = event.newIndex;
        if (oldIndex === newIndex) {
            return;
        }
        // Restore the real DOM structure. Otherwise, the React virtual DOM is out of sync with real DOM.
        if (listRef.current) {
            var targetElement = event.item;
            var originalNextIndex = oldIndex < newIndex ? oldIndex : oldIndex + 1;
            var originalNextElement = listRef.current.children.item(originalNextIndex);
            listRef.current.insertBefore(targetElement, originalNextElement);
        }
        // Call `onReorderItem` callback to notify parent to re-render with React.
        if (props.onReorderItem) {
            props.onReorderItem(event.oldIndex, event.newIndex);
        }
    }
    return (React.createElement("div", { className: 'sortable', "aria-label": props['aria-label'], "aria-describedby": props['aria-describedby'], "data-automation-id": props['data-automation-id'], ref: listRef, role: (_a = props['aria-role']) !== null && _a !== void 0 ? _a : 'list' }, props.children));
}
exports.SortableList = SortableList;
//# sourceMappingURL=SortableList.js.map