"use strict";
// Copyright (c) Microsoft. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortableAccordionImpl = exports.SortableAccordion = exports.PropertyPaneSortableAccordion = void 0;
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var react_components_1 = require("@fluentui/react-components");
var react_icons_1 = require("@fluentui/react-icons");
var react_tabster_1 = require("@fluentui/react-tabster");
var sp_core_library_1 = require("@microsoft/sp-core-library");
var screen_reader_alert_1 = require("@ms/screen-reader-alert");
var odsp_utilities_bundle_1 = require("@ms/odsp-utilities-bundle");
var SortableList_1 = require("./SortableList");
var IPropertyPaneField_1 = require("../propertyPaneField/IPropertyPaneField");
var hooks_1 = require("./hooks");
var PropertyPaneSortableAccordion_styles_1 = require("./PropertyPaneSortableAccordion.styles");
var PropertyPaneSortableAccordionStrings_resx_1 = tslib_1.__importDefault(require("./PropertyPaneSortableAccordionStrings.resx"));
/**
 * Helper method to create a sortable accordion on the PropertyPane.
 * @param targetProperty - Target property the sortable accordion is associated to.
 * @param properties - Strongly typed sortable accordion properties.
 *
 * @internal
 */
function PropertyPaneSortableAccordion(targetProperty, properties) {
    return {
        type: IPropertyPaneField_1.PropertyPaneFieldType.SortableAccordion,
        targetProperty: targetProperty,
        properties: properties
    };
}
exports.PropertyPaneSortableAccordion = PropertyPaneSortableAccordion;
function SortableAccordion(props) {
    return (React.createElement(react_components_1.FluentProvider, { dir: (document.dir || 'ltr') },
        React.createElement(SortableAccordionImpl, tslib_1.__assign({}, props))));
}
exports.SortableAccordion = SortableAccordion;
function SortableAccordionImpl(props) {
    var _a, _b;
    var styles = (0, PropertyPaneSortableAccordion_styles_1.useStyles)();
    var groupField = props.groupField, onUpdateData = props.onUpdateData;
    var items = groupField.properties.items;
    var _c = (0, hooks_1.useOpenItemId)(groupField.properties.openItemId, groupField.properties.defaultOpenItemId), openItemId = _c[0], setOpenItemId = _c[1];
    var focusItemIndex = React.useRef(null);
    var itemsRef = React.useRef(new Array(items.length));
    React.useLayoutEffect(function () {
        if (focusItemIndex.current !== null) {
            itemsRef.current[focusItemIndex.current].focus();
            focusItemIndex.current = null;
        }
    }, [items, itemsRef]);
    var verticalNavAttr = (0, react_tabster_1.useArrowNavigationGroup)({
        axis: 'vertical',
        memorizeCurrent: true,
        circular: true
    });
    var horizontalNavAttr = (0, react_tabster_1.useArrowNavigationGroup)({
        axis: 'horizontal',
        memorizeCurrent: true,
        circular: true
    });
    var limitedFocusGroupAttr = (0, react_tabster_1.useFocusableGroup)({
        tabBehavior: 'limited',
        ignoreDefaultKeydown: { Enter: true }
    });
    var focusGroupAttr = (0, react_tabster_1.useFocusableGroup)();
    var handleListItemKeyDown = React.useCallback(function (e) {
        if (e.defaultPrevented) {
            return;
        }
        // if an event is triggered from an element inside the list item
        if (e.target !== e.currentTarget) {
            // for arrow left and right, leave it for horizontal navigation
            // for up and down, we need to manually move focus to the next/previous item
            switch (e.key) {
                case 'ArrowDown':
                case 'ArrowUp':
                    e.preventDefault();
                    e.target.dispatchEvent(new react_tabster_1.GroupperMoveFocusEvent({ action: react_tabster_1.GroupperMoveFocusActions.Escape }));
                    e.currentTarget.dispatchEvent(new react_tabster_1.MoverMoveFocusEvent({ key: react_tabster_1.MoverKeys[e.key] }));
            }
            return;
        }
        // if an event is triggered from the list item itself, we need to manually move focus into the inside items
        switch (e.key) {
            case 'ArrowLeft':
            case 'ArrowRight':
                e.preventDefault();
                e.target.dispatchEvent(new react_tabster_1.GroupperMoveFocusEvent({ action: react_tabster_1.GroupperMoveFocusActions.Enter }));
        }
    }, []);
    var handleClickItem = function (itemId) {
        var _a, _b;
        var newOpenItemId = openItemId === itemId ? '' : itemId;
        setOpenItemId(newOpenItemId);
        (_b = (_a = groupField.properties).onToggle) === null || _b === void 0 ? void 0 : _b.call(_a, newOpenItemId);
    };
    var handleDeleteItem = function (index, deleteAlert) {
        var _a, _b;
        var newItems = items.map(function (item) { return item.itemData; });
        newItems.splice(index, 1);
        (_b = (_a = groupField.properties).onItemDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, index);
        onUpdateData(groupField.targetProperty, newItems);
        focusItemIndex.current = index < items.length - 1 ? index : Math.max(0, index - 1);
        if (deleteAlert) {
            screen_reader_alert_1.ScreenReaderAlert.read(deleteAlert, screen_reader_alert_1.ReadingMode.ReadImmediately);
        }
    };
    var handleReorderItems = React.useCallback(function (oldIndex, newIndex) {
        var newItems = items.map(function (item) { return item.itemData; });
        var removed = newItems.splice(oldIndex, 1)[0];
        newItems.splice(newIndex, 0, removed);
        onUpdateData(groupField.targetProperty, newItems);
    }, [groupField.targetProperty, items, onUpdateData]);
    var handleUpdateItemData = function (index, newValue) {
        onUpdateData("".concat(groupField.targetProperty, "[").concat(index, "]"), newValue);
    };
    var handleUpdateGroupData = function (newValue) {
        onUpdateData(groupField.targetProperty, newValue);
    };
    var handleDragIconKeyDown = function (index, event) {
        var isMac = sp_core_library_1._BrowserDetection.getBrowserInformation().os === sp_core_library_1._OS.Mac;
        var mainKey = isMac ? event.metaKey : event.ctrlKey;
        switch (event.key) {
            case 'ArrowUp':
                if (mainKey) {
                    var newIndex = index === 0 ? items.length - 1 : index - 1;
                    event.preventDefault();
                    handleReorderItems(index, newIndex);
                }
                break;
            case 'ArrowDown':
                if (mainKey) {
                    var newIndex = index === items.length - 1 ? 0 : index + 1;
                    event.preventDefault();
                    handleReorderItems(index, newIndex);
                }
                break;
        }
    };
    return (React.createElement(React.Fragment, null, (_b = (_a = groupField.properties).onRenderPlaceholder) === null || _b === void 0 ? void 0 :
        _b.call(_a, handleUpdateGroupData),
        items.length > 0 && (
        // The sticky position is a workaround to fix the wired drag preview issue caused by some dummy elements added by tabster for focus management.
        React.createElement("div", tslib_1.__assign({}, verticalNavAttr, { style: { position: 'sticky' } }),
            React.createElement(SortableList_1.SortableList, { displayMode: sp_core_library_1.DisplayMode.Edit, onReorderItem: handleReorderItems, "aria-role": 'grid' }, items.map(function (item, index) {
                var _a, _b, _c, _d;
                var isItemOpen = openItemId === item.id;
                return (React.createElement("div", { key: item.id, role: 'none', style: { position: 'sticky' } },
                    React.createElement("div", tslib_1.__assign({ "data-drag-tag": SortableList_1.DRAG_LEAF_TAG }, focusGroupAttr, { role: 'none' }),
                        React.createElement("div", tslib_1.__assign({ className: styles.accordionItem, style: {
                                '--focusIndicatorDisplay': isItemOpen ? 'block' : 'none'
                            }, role: 'row', 
                            // eslint-disable-next-line react/jsx-no-bind
                            ref: function (node) {
                                if (node) {
                                    itemsRef.current[index] = node;
                                }
                                else {
                                    itemsRef.current.splice(index, 1);
                                }
                            }, "aria-label": item.title, tabIndex: 0 }, limitedFocusGroupAttr, { onKeyDown: handleListItemKeyDown }),
                            React.createElement("div", tslib_1.__assign({ className: styles.accordionItemHeader }, horizontalNavAttr, { role: 'none' }),
                                React.createElement("div", { role: 'gridcell' },
                                    React.createElement(react_components_1.Button, { icon: isItemOpen ? (React.createElement(react_icons_1.ReOrderDotsVertical20Filled, { color: react_components_1.tokens.colorBrandBackground })) : (React.createElement(react_icons_1.ReOrderDotsVertical20Regular, null)), "data-drag-handle": SortableList_1.DRAG_HANDLE_TAG, className: styles.dragButton, title: odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.ReorderButtonAriaLabel, (_a = groupField.properties.itemEntityName) !== null && _a !== void 0 ? _a : PropertyPaneSortableAccordionStrings_resx_1.default.DefaultItemEntityName), 
                                        // eslint-disable-next-line react/jsx-no-bind
                                        onKeyDown: function (evt) { return handleDragIconKeyDown(index, evt); } })),
                                React.createElement("span", tslib_1.__assign({ className: styles.accordionItemTitle }, (isItemOpen && {
                                    style: {
                                        color: react_components_1.tokens.colorBrandBackground,
                                        fontWeight: react_components_1.tokens.fontWeightSemibold
                                    }
                                }), { 
                                    // eslint-disable-next-line react/jsx-no-bind
                                    onClick: function () { return handleClickItem(item.id); } }), item.title),
                                React.createElement("div", { className: styles.accordionItemButtons, role: 'none' },
                                    !item.hideDeleteButton && (React.createElement("div", { role: 'gridcell' },
                                        React.createElement(react_components_1.Button, { className: (0, react_components_1.mergeClasses)('deleteButton', styles.deleteButton), icon: React.createElement(react_icons_1.Delete20Regular, null), title: odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.DeleteButtonAriaLabel, (_b = groupField.properties.itemEntityName) !== null && _b !== void 0 ? _b : PropertyPaneSortableAccordionStrings_resx_1.default.DefaultItemEntityName), 
                                            // eslint-disable-next-line react/jsx-no-bind
                                            onClick: function () { return handleDeleteItem(index, item.deleteItemAlert); } }))),
                                    !groupField.properties.disableAccordion && (React.createElement("div", { role: 'gridcell' },
                                        React.createElement(react_components_1.Button, { icon: isItemOpen ? React.createElement(react_icons_1.ChevronUp20Regular, null) : React.createElement(react_icons_1.ChevronDown20Regular, null), className: styles.collapseButton, 
                                            // eslint-disable-next-line react/jsx-no-bind
                                            onClick: function () {
                                                handleClickItem(item.id);
                                            }, title: isItemOpen
                                                ? odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.HideItemButtonAriaLabel, (_c = groupField.properties.itemEntityName) !== null && _c !== void 0 ? _c : PropertyPaneSortableAccordionStrings_resx_1.default.DefaultItemEntityName)
                                                : odsp_utilities_bundle_1.StringHelper.format(PropertyPaneSortableAccordionStrings_resx_1.default.ShowItemButtonAriaLabel, (_d = groupField.properties.itemEntityName) !== null && _d !== void 0 ? _d : PropertyPaneSortableAccordionStrings_resx_1.default.DefaultItemEntityName) })))))),
                        !groupField.properties.disableAccordion && isItemOpen && (React.createElement("div", { className: styles.itemConfigurePane }, item.onRenderItemConfiguration(function (itemData) {
                            handleUpdateItemData(index, itemData);
                        }))))));
            }))))));
}
exports.SortableAccordionImpl = SortableAccordionImpl;
//# sourceMappingURL=PropertyPaneSortableAccordion.js.map