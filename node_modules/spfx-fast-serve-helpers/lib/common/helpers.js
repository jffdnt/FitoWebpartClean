"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJSONFile = getJSONFile;
exports.getLoggingLevel = getLoggingLevel;
exports.getEntryPoints = getEntryPoints;
exports.addCopyLocalizedResources = addCopyLocalizedResources;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.trim = trim;
exports.createKeyFromPath = createKeyFromPath;
exports.createResourcesMap = createResourcesMap;
exports.freePortIfInUse = freePortIfInUse;
exports.checkVersions = checkVersions;
exports.getExternalComponents = getExternalComponents;
exports.createLocalExternals = createLocalExternals;
exports.addCopyLocalExternals = addCopyLocalExternals;
exports.needToRunBundle = needToRunBundle;
exports.getNpmScriptValue = getNpmScriptValue;
exports.customParseInt = customParseInt;
exports.customParseBoolean = customParseBoolean;
exports.getTemplatesPath = getTemplatesPath;
exports.nanoToSeconds = nanoToSeconds;
exports.ensureFastServeFolder = ensureFastServeFolder;
exports.extractLibraryComponents = extractLibraryComponents;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const globby_1 = __importDefault(require("globby"));
const get_port_1 = __importDefault(require("get-port"));
const colors_1 = __importDefault(require("colors"));
const killPort = require('kill-port');
const logger_1 = require("./logger");
const consts_1 = require("./consts");
const commander_1 = require("commander");
function getJSONFile(relPath) {
    const filePath = path.join(process.cwd(), relPath);
    if (!fs.existsSync(filePath)) {
        return null;
    }
    return require(filePath);
}
function getLoggingLevel(level) {
    if (level === 'minimal') {
        return {
            all: false,
            colors: true,
            errors: true
        };
    }
    if (level === 'normal') {
        return {
            all: false,
            colors: true,
            errors: true,
            warnings: true,
            timings: true,
            entrypoints: true
        };
    }
    if (level === 'detailed') {
        return {
            all: false,
            colors: true,
            errors: true,
            timings: true,
            assets: true,
            warnings: true
        };
    }
    throw new Error('Unsupported log level: ' + level);
}
function getEntryPoints(entry) {
    const newEntry = {};
    for (const key in entry) {
        let entryPath = entry[key].import;
        if (entryPath.indexOf('bundle-entries') === -1) {
            entryPath = createTsEntryPath(entryPath);
        }
        else {
            let bundleContent = fs.readFileSync(entryPath).toString();
            bundleContent = createTsEntriesForBundledPackage(bundleContent);
            fs.writeFileSync(entryPath, bundleContent);
        }
        newEntry[key] = entry[key];
        newEntry[key].import = entryPath;
    }
    return newEntry;
}
function createTsEntriesForBundledPackage(content) {
    const search = /from '(?<jsPath>.*)'/gi;
    let newContent = content.slice();
    let match = search.exec(content);
    do {
        const jsPath = match.groups.jsPath;
        const tsPath = createTsEntryPath(jsPath);
        newContent = newContent.replace(jsPath, tsPath);
    } while ((match = search.exec(content)) !== null);
    return newContent;
}
function createTsEntryPath(jsPath) {
    const libSearchRegexp1 = /\/lib\//gi;
    const libSearchRegexp2 = /\\lib\\/gi;
    const srcPathToReplace1 = '/src/';
    const srcPathToReplace2 = '\\src\\';
    const tsPath = jsPath
        .replace(libSearchRegexp1, srcPathToReplace1)
        .replace(libSearchRegexp2, srcPathToReplace2)
        .slice(0, -3) + '.ts';
    return getEntryPath(tsPath);
}
function getEntryPath(tsPath) {
    let pathToCheck = tsPath;
    if (!path.isAbsolute(pathToCheck)) {
        const bundledEntriesPath = path.join(process.cwd(), 'temp/bundle-entries');
        pathToCheck = path.join(bundledEntriesPath, pathToCheck);
    }
    if (fs.existsSync(pathToCheck)) {
        return tsPath;
    }
    pathToCheck = pathToCheck + 'x';
    if (fs.existsSync(pathToCheck)) {
        return tsPath + 'x';
    }
    throw new Error('Unable to resolve entry path. Path received: ' + tsPath);
}
function addCopyLocalizedResources(localizedResources) {
    const patterns = [];
    for (const resourceKey in localizedResources) {
        const resourcePath = localizedResources[resourceKey];
        const from = resourcePath.replace(/^lib/gi, 'src').replace('{locale}', '*');
        patterns.push({
            from,
            noErrorOnMissing: true,
            to: (data) => {
                let fileName = path.basename(data.absoluteFilename);
                if (!resourcePath.endsWith('{locale}.js')) {
                    fileName = 'default.js';
                }
                return resourceKey + '_' + fileName;
            }
        });
    }
    return patterns;
}
function trimLeft(str, charlist) {
    return str.replace(new RegExp('^[' + charlist + ']+'), '');
}
function trimRight(str, charlist) {
    return str.replace(new RegExp('[' + charlist + ']+$'), '');
}
function trim(str, charlist) {
    return trimRight(trimLeft(str, charlist), charlist);
}
function createKeyFromPath(path) {
    return trimLeft(path, '/\\\\').replace(/\//gi, '|').replace(/\\/gi, '|');
}
function createResourcesMap(localizedResources) {
    const resourcesMap = {};
    for (const resourceKey in localizedResources) {
        const resourcePath = localizedResources[resourceKey];
        const search = resourcePath.replace(/^lib/gi, 'src').replace('{locale}.js', '*.ts');
        const exclude = '!' + search.replace('*.ts', '*.d.ts');
        const typescriptResources = globby_1.default.sync([search, exclude], {
            cwd: process.cwd()
        });
        if (!(typescriptResources === null || typescriptResources === void 0 ? void 0 : typescriptResources.length)) {
            continue;
        }
        for (const resourcePath of typescriptResources) {
            const key = createKeyFromPath(resourcePath);
            const fileName = `${resourceKey}_${path.basename(resourcePath).replace('.ts', '.js')}`;
            resourcesMap[key] = {
                path: trimLeft(resourcePath, '/\\\\'),
                fileName
            };
        }
    }
    return resourcesMap;
}
async function freePortIfInUse(port) {
    const freePort = await (0, get_port_1.default)({ port, host: 'localhost' });
    if (freePort !== port) {
        logger_1.Logger.log(colors_1.default.yellow(`The port ${port} is in use. Trying to release...`));
        await killPort(port);
        logger_1.Logger.log(colors_1.default.yellow(`The port ${port} is successfully released.`));
    }
}
function checkVersions() {
    var _a;
    const packageJson = getJSONFile('package.json');
    if (((_a = packageJson.devDependencies[consts_1.fastServemoduleName]) === null || _a === void 0 ? void 0 : _a.indexOf(':')) !== -1) {
        return;
    }
    const spfxVersion = getSpfxMinorVersion(packageJson);
    const fastServeVersion = getMinorVersion(packageJson, consts_1.fastServemoduleName);
    if (spfxVersion !== fastServeVersion) {
        throw new Error(`SPFx Fast Serve: version mismatch. We detected the usage of SPFx 1.${spfxVersion}, but "${consts_1.fastServemoduleName}" version is 1.${fastServeVersion}. Please change "spfx-fast-serve-helpers" version to ~1.${spfxVersion}.0, delete node_modules, package-lock.json and reinstall dependencies.`);
    }
}
function getSpfxMinorVersion(packageJson) {
    var _a;
    let version = packageJson.dependencies[consts_1.spfxDependecyToCheck];
    if (!version) {
        const yoPath = path.join(process.cwd(), '.yo-rc.json');
        const yoJson = require(yoPath);
        version = (_a = yoJson['@microsoft/generator-sharepoint']) === null || _a === void 0 ? void 0 : _a.version;
        if (!version) {
            throw new Error('Cannot find SPFx version in package.json or .yo-rc.json');
        }
    }
    if (version.indexOf('~') === 0 || version.indexOf('^') === 0) {
        version = version.substr(1);
    }
    return parseInt(version.split('.')[1]);
}
function getMinorVersion(packageJson, dependecyToCheck) {
    let version = packageJson.devDependencies[dependecyToCheck];
    if (!version) {
        version = packageJson.dependencies[dependecyToCheck];
    }
    if (!version) {
        throw new Error(`SPFx Fast Serve: unable to find dependency ${dependecyToCheck}`);
    }
    if (version.indexOf('~') === 0 || version.indexOf('^') === 0) {
        version = version.substr(1);
    }
    return parseInt(version.split('.')[1]);
}
function getExternalComponents() {
    const originalWebpackConfig = getJSONFile('temp/_webpack_config.json');
    for (const plugin of originalWebpackConfig.plugins) {
        if (plugin._options && plugin._options.externalComponents) {
            return plugin._options.externalComponents;
        }
    }
    throw new Error('Unable to resolve AsyncComponentPlugin');
}
function createLocalExternals(externals) {
    if (!externals)
        return null;
    const result = {};
    for (const name in externals) {
        const info = externals[name];
        if (typeof info === 'string') {
            if (info.startsWith('http')) {
                continue;
            }
            result[name] = { path: info };
        }
        else {
            if (info.path.startsWith('http')) {
                continue;
            }
            result[name] = { path: info.path };
        }
    }
    return result;
}
function addCopyLocalExternals(externals, manifest, originalEntries) {
    if (!externals)
        return [];
    const patterns = [];
    for (const { manifestData: jsModule } of manifest) {
        if (jsModule.loaderConfig
            && jsModule.loaderConfig.entryModuleId
            && originalEntries.indexOf(jsModule.loaderConfig.entryModuleId) !== -1) {
            for (const resourceKey in jsModule.loaderConfig.scriptResources) {
                const resource = jsModule.loaderConfig.scriptResources[resourceKey];
                if (externals[resourceKey]) {
                    const from = externals[resourceKey].path;
                    const to = resource.path;
                    if (!hasPattern(patterns, to)) {
                        patterns.push({
                            from,
                            noErrorOnMissing: true,
                            to
                        });
                    }
                }
            }
        }
    }
    return patterns;
}
function needToRunBundle() {
    const npmScript = process.env.npm_lifecycle_event;
    if (!npmScript || npmScript === 'npx')
        return true;
    const packageJson = getJSONFile('package.json');
    const script = packageJson.scripts[npmScript];
    if (script.indexOf('--custom-serve') !== -1) {
        logger_1.Logger.log(colors_1.default.yellow('We detected the old-styled "serve" command. Consider using just "fast-serve" instead. More info: https://github.com/s-KaiNet/spfx-fast-serve/blob/master/docs/Migrate-from-3-to-4.md'));
        return false;
    }
    return true;
}
function getNpmScriptValue() {
    const npmScript = process.env.npm_lifecycle_event;
    if (!npmScript || npmScript === 'npx')
        return null;
    const packageJson = getJSONFile('package.json');
    return packageJson.scripts[npmScript];
}
function customParseInt(value) {
    const parsedValue = parseInt(value, 10);
    if (isNaN(parsedValue)) {
        throw new commander_1.InvalidArgumentError('Not a number');
    }
    return parsedValue;
}
function customParseBoolean(value) {
    if (!value)
        return false;
    return value.toLowerCase() === 'true';
}
function getTemplatesPath(fileName) {
    const basePath = 'templates/';
    return path.join(__dirname, '..', basePath + fileName);
}
function nanoToSeconds(nano) {
    return (Number(nano) / 1000000000).toFixed(2);
}
function ensureFastServeFolder() {
    const fastServeFolder = path.join(process.cwd(), consts_1.fastFolderName);
    if (!fs.existsSync(fastServeFolder)) {
        fs.mkdirSync(fastServeFolder);
    }
}
function extractLibraryComponents(manifests) {
    const results = [];
    const rootFolder = path.resolve(process.cwd());
    for (const manifest of manifests) {
        for (const resourceKey in manifest.manifestData.loaderConfig.scriptResources) {
            const resource = manifest.manifestData.loaderConfig.scriptResources[resourceKey];
            if (resource.type !== 'component' || resourceKey.indexOf('@microsoft/') === 0 || resourceKey.indexOf('@ms/') === 0)
                continue;
            const manifestPackage = findPackage(manifests, resourceKey);
            if (!manifestPackage)
                continue;
            const packageRelPath = getPackageRelativePath(manifestPackage);
            if (!packageRelPath)
                continue;
            if (!isLibraryComponentResource(packageRelPath))
                continue;
            results.push({
                directory: path.resolve(rootFolder, `${packageRelPath}/dist`),
                publicPath: `/${packageRelPath}/dist`
            });
        }
    }
    return results;
}
function isLibraryComponentResource(packageRelPath) {
    const rootFolder = path.resolve(process.cwd());
    const pathToTest = path.resolve(rootFolder, `${packageRelPath}/config/package-solution.json`);
    return fs.existsSync(pathToTest);
}
function getPackageRelativePath(manifest) {
    if (!manifest.relativeManifestPath) {
        return null;
    }
    const parts = manifest.relativeManifestPath.split('/');
    if (parts.length < 3) {
        return null;
    }
    return parts.slice(0, -2).join('/');
}
function findPackage(manifests, name) {
    for (const manifest of manifests) {
        if (manifest.packageName === name)
            return manifest;
    }
    return null;
}
function hasPattern(patterns, to) {
    for (const pattern of patterns) {
        if (pattern.to === to) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=helpers.js.map